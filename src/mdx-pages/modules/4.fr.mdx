---
title: "Module 4 : Service web & clients"
description: "Cr√©ation de services web, de RESTful API & requ√™tes clientes"
---

# Module 4 : Service web & clients
Ce module vous offre principalement la cr√©ation de services web et la mise en place de requ√™tes clientes pour tester des RESTful API.

Voici les sujets trait√©s :
- a) [Introduction au backend](#a)
- b) [Introduction √† Node.js](#b)
  - b.1) [Introduction](#b1)
  - b.2) [Ou mettre du code Node.js ?](#b2)
  - b.3) [Les modules CommonJS](#b3)
  - b.4) [Introduction aux packages](#b4)
- c) [Introduction √† Express](#c)
  - c.1) [Introduction](#c1)
  - c.2) [Cr√©er une application Express "from scratch"](#c2)
  - c.3) [Cr√©er une application Express via un g√©n√©rateur](#c3)
- d) [Introduction aux RESTful API](#d)
  - d.1) [Introduction](#d1)
  - d.2) [Conventions REST](#d2)
- e) [Introduction aux RESTful API via Express](#e)
  - e.1) [Introduction](#e1)
  - e.2) [Configuration et d√©marrage d'une application Express](#e2)
  - e.3) [Serveur web int√©gr√©](#e3)
  - e.4) [Les fonctions middleware en Express](#e4)
  - e.5) [D√©finition d'une route en Express](#e5)
  - e.6) [Op√©ration de lecture](#e6)
  - e.7) [Chemin et param√®tres de route](#e7)
  - e.8) [Chemin et param√®tres de requ√™te](#e8)
  - e.9) [Op√©ration de cr√©ation & parsing du body](#e9)
  - e.10) [Client REST](#e10) 
  - e.11) [R√©pondre avec un code de statut HTTP](#e11) 
  - e.12) [Op√©ration de suppression](#e12)
  - e.13) [Op√©ration de modification](#e13) 
- f) [Spread operator](#f)
- g) [Exercice 4.1 : Cr√©ation d'une RESTfull API non prot√©g√©e pour myMovies](#g)
- h) [üç¨ Exercice 4.2 : Gestion de la pagination, de l'ordre de pr√©sentation et du filtrage de films](#h)

# <a id="a"></a>a) Introduction au backend
## a.1) Frontend, backend, c'est quoi ?
Un **frontend**, c'est une application :
- qui s'ex√©cute c√¥t√© client, une IHM, qu'on pourrait aussi appeler UI ;
- qui est en direct interaction avec l'utilisateur ;
- impl√©ment√©, dans ce cours-ci, en HTML / CSS / JS.

Un **backend**, c'est une application :
- qui s'ex√©cute c√¥t√© serveur ; 
- qui n'offre pas d'interaction directe avec l'utilisateur ;
- qui parfois met √† disposition le **frontend** ;
- qui parfois offre des op√©rations sur des donn√©es.

## a.2) R√¥les principaux du backend
### a.2.1) Fourniture du frontend
Un des r√¥les du backend est de fournir le frontend :
- **via un serveur de fichiers statiques** ; c'est la mise √† disposition des assets : fichiers HTML, CSS, JS, images...
- **via la g√©n√©ration dynamique de pages HTML** ; c'est ce qui se passe quand le backend fait du Server Side Rendering (SSR), g√©n√©ralement dans le cadre de Multi Page Applications.  

Dans le cadre de ce cours, nous ne ferons pas de g√©n√©ration dynamique d'HTML c√¥t√© serveur (ou SSR).  
Par contre, nous avons d√©j√† vu :
- comment faire de la g√©n√©ration dynamique d'HTML c√¥t√© client (ou Client Side Rendering = CSR).
- mettre √† disposition notre frontend, notre IHM, √† l'aide d'un serveur de fichiers statiques : c'est ce que notamment fait le serveur de d√©veloppement de Webpack, il me √† disposition les assets permettant au browser d'ex√©cuter l'application web.

### a.2.2) Fourniture d'op√©rations sur des ressources
Un autre r√¥le important du backend est de mettre √† disposition des op√©rations sur des ressources, c'est ce qu'on appelle les services web ou web API.

Il existe diff√©rents types de technologies et architectures web permettant d'impl√©menter des web services, notamment :
- **RESTful API** ; c'est l'architecture qui actuellement est la plus utilis√©e et qui sera apprise dans le cadre de ce cours.
- **GraphQL API** ; c'est une technologie r√©cente qui permet de tr√®s rapidement cr√©er des requ√™tes sur des ressources et qui a √©t√© cr√©√©e par Facebook ; nous ne verrons pas cette technologie dans le cadre de ce cours.
- **SOAP API** ; c'est une fa√ßon ancienne de cr√©er des op√©rations sur des ressources mettant en oeuvre de l'XML pour communiquer entre des applications clients / serveurs. Nous ne verrons pas cette technologie dans le cadre de ce cours.

### a.2.3) Autres r√¥les du backend ?
Un backend peut offrir d'autres services, comme :
- **proxy** : interm√©diaire entre les clients demandant une ressource et le serveur fournissant cette ressource. On verra ce type de service, notamment pour masquer l'origine d'une requ√™te √† une API.
- **reverse proxy** : c'est un serveur qui fait l'interm√©diaire avec d'autres serveurs, cachant au client qui est le v√©ritable serveur ayant trait√© de sa requ√™te. Par exemple, un proxy serveur peut mettre √† disposition des acc√®s √† des serveurs interne √† une entreprise (non visibles sur le web) alors que le client interroge un serveur qui est visible sur le web.
- **serveur d'emails** ;
- ...

### a.2.3) Technologies backend possibles

Voici un exemple de technologies qui pourrait √™tre mises en oeuvre pour d√©velopper une application backend :

<ScrollableImage name="techno.png" minWidth="586px" maxWidth="586px" />

  <figcaption>Technologies backend possibles</figcaption>

### a.2.4) Technologies backend s√©lectionn√©es pour ce cours

Voici les technologies qui ont √©t√© choisies pour √™tre mises en oeuvre pour d√©velopper une application backend en JS :

<ScrollableImage name="techno-course.png" minWidth="721px" maxWidth="721px" />

  <figcaption>Technologies backend en JS choisies pour ce cours</figcaption>

Nous allons utiliser Express comme framework pour rapidement d√©velopper des applications Node.js.

# <a id="b"></a>b) Introduction √† Node.js
## <a id="b1"></a> b.1) Introduction
Node.js est un environnement serveur open source permettant la cr√©ation d'outils et applications c√¥t√© serveur en JS.  
Node.js offre une utilisation optimale des ressources des serveurs sans d√©pendance √† un serveur http externe, tout en √©tant multiplateforme (Windows, Linux, Mac‚Ä¶).

Pour le d√©veloppement d'IHM de fa√ßon modernes, vous avez d√©j√† install√© l'environnement Node.js. Mais si √ßa n'est pas install√©, il est important que vous installiez l'environnement [Node.js en version LTS](https://nodejs.org/en/) [[R.34]](/references/#r34).

Vous ne devez pas apprendre un nouveau langage pour d√©velopper des applications backend, Node.js, c'est du JS.  
Si vous avez besoin d'un rappel du langage, vous pouvez le faire ici : [Introduction au langage JS](/intro/#e).

Tr√®s souvent, Node.js est cod√© en JS conforme au standard CommonJS.  
La gestion des modules est diff√©rente du JS conforme au standard ECMAScript, telle que nous avons appris pour du JS c√¥t√© browser.

M√™me s'il est possible d'√©crire du Node.js conforme au standard ECMAScript, la majorit√© du code que vous trouverez sur le web sera conforme √† CommonJS.

D√®s lors, nous allons vous expliquer plus tard comment g√©rer des modules en Node.js conforme au standard CommonJS.

## <a id="b2"></a> b.2) Ou mettre du code Node.js ?
### b.2.1) Directement dans un terminal
Il est possible d'√©crire du code Node.js directement dans un terminal.

Pour rappel, nous vous conseillons d'utiliser Git Bash comme terminal au sein de VS Code. 

Vous devriez d√©j√† avoir configur√© VS Code pour avoir comme Terminal par d√©faut 
Git Bash. Si √ßa n'est pas fait, nous vous rappelons la proc√©dure :
- Vous devez avoir install√© Git sur votre machine.
- Cliquez √† droite du **+** au sein d'un terminal ouvert dans VS Code, clic sur **Select Default Profile**, puis s√©lectionnez "Git Bash". Tous les prochains terminaux que vous ouvrirez le seront sous Git Bash, nettement plus color√© et int√©ressant que les autres terminaux üòé.

<ScrollableImage name="terminal-2.png" minWidth="933px" maxWidth="933px" />

<figcaption>Choix du terminal par d√©faut</figcaption>

Veuillez tester du code Node.js directement dans un terminal en tapant cela au sein d'un terminal de VS Code :

```bash
node
```

Vous avez maintenant acc√®s au terminal de Node.js.  
Vous pouvez tenter une op√©ration math√©matique de votre choix, comme par exemple : **2 * Math.PI**

Incroyable mais vrai, vous avez maintenant acc√®s √† une nouvelle calculatrice sur tous les appareils o√π vous avez Node.js install√©. Et si Node.js n'est pas install√©, pas de panique, la console de votre Browser pourra toujours vous aider üòâ.

Quand vous souhaitez sortir de l'interpr√©teur de commandes de Nodes, il faut taper :
- soit deux fois **`CTRL c`**
- soit **`CTRL d`**

### b.2.2) Dans un script
Nous √©crivons g√©n√©ralement le code Node.js au sein d'un script externe.

Dans votre repo **web2**, veuillez cr√©er un r√©pertoire **/tutorials/node-start** et y ajouter le fichier **start.js** contenant ce code-ci :

```js
class Car {
  constructor(brand, model) {
    this.brand = brand;
    this.model = model;
    this.id = Math.random();
  }

  getDescription() {
    return `Car's description : ${this.brand}, ${this.model} , ID:${this.id}`;
  }
}

const dacia = new Car('Dacia', 'Sandero');

console.log( dacia.getDescription() );
```

Pour lancer une application Node.js, il suffit de taper dans un terminal : **`node nomScript`** (**`.js`** est optionnel).

Donc pour lancer le script cr√©√© ci-dessus, veuillez ouvrir un terminal au bon endroit.  
Pour rappel, Il est possible de faire un clic droit dans l'Explorer de VS Code sur le r√©pertoire **node-start**, **Open in Integrated Terminal** pour ouvrir un terminal √† l'endroit souhait√©.

Il ne vous reste plus qu'√† taper :

```bash
node start # or node start.js
```

Voil√†, c'est une simple application Node.js qui affiche un message dans le terminal.

## <a id="b3"></a> b.3) Les modules CommonJS
### b.3.1) Introduction
Un module est une librairie JS fournissant des objets.  
Comme en JS tout est objet, un module met donc √† disposition des fonctions, des constantes, des variables...

### b.3.2) Cr√©ation d'un module
Pour cr√©er un module, il suffit de cr√©er un script JS **nomModule.js** et d'exporter des objets au sein de ce module via **module.exports** ou **exports**.

### b.3.3) Exporter des objets
#### b.3.3.1) Introduction
Il existe plusieurs fa√ßons d'exporter des objets, soit √† la vol√©e, soit √† la fin d'un script.

üëç Nous vous recommandons de faire vos exports √† la fin du script, cela rend les scripts plus lisibles. 

Nous allons n√©anmoins voir toutes les fa√ßons d'exporter des objets en CommonJS, car vous trouverez de tout sur le web.

On exporte toujours un seul objet principal dans un module. Cet objet peut bien s√ªr contenir une multitude d'objets via ses propri√©t√©s.

#### b.3.3.2) Export √† la fin d'un script
C'est la fa√ßon la plus propre d'exporter un seul objet :

```js
module.exports¬†=¬†router;
```

C'est l'√©quivalent d'un "default export" tel que vu en ECMAScript.

S'il y a plusieurs objets √† exporter, voici la fa√ßon recommand√©e de le faire : 

```js
module.exports¬†=¬†{authorize,¬†users¬†};
```

C'est l'√©quivalent d'un "Named export" tel que vu en ECMAScript.

#### b.3.3.3) Export √† la vol√©e

Il est possible de faire des exports √† la vol√©e, c'est √† dire d'exporter des objets au fur et √† mesure qu'ils sont initialis√©s.

Voici la version longue :

```js
module.exports.authorize¬†=¬†authorize;
module.exports.users¬†=¬†users¬†;
```

Il est aussi possible d'√©courter une export √† la vol√©e : 
```js
exports.authorize¬†=¬†authorize;
exports.users¬†=¬†users¬†;
```

Voici quelques pr√©cisions :
- **`module.exports`** : c'est la r√©f√©rence de l'objet retourn√©e par l'appel de **`required()`** (m√©thode qui sera utilis√©e pour l'import).
- **`exports`** : c'est la r√©f√©rence vers **`module.exports`**, **`exports`** n'est pas retourn√© par l'appel de **`required()`**.

‚ö° Il faut faire attention au mauvais usage de l'utilisation de **`exports`**.  
Voici une mauvaise utilisation :

```js
exports¬†=¬†{¬†authorize,¬†users¬†};¬†/*¬†exports¬†has¬†a¬†new¬†reference,¬†
                                   it¬†is¬†no¬†longer¬†linked¬†to¬†module.exports */
```

### b.3.4) Importer des objets
#### b.3.4.1) Introduction
Pour utiliser des objets (fonctions, constantes, objets, classes...) au sein d'un script JS provenant de modules, on le fait √† l'aide de la fonction **`required()`** et du chemin vers le module √† utiliser.

Il est possible d'importer tant des objets de modules que l'on a cr√©√© soi-m√™me, que de packages mis √† disposition via un gestionnaire de packages.

#### b.3.4.2) Import d'un module
Lorsqu'un seul objet a √©t√© export√©, on l'importe en lui donnant le nom que l'on souhaite √† l'import et en indiquant le chemin vers le module √† utiliser.

```js
const¬†pizzaRouter¬†=¬†require('./routes/pizzas');
```

Lorsque plusieurs objets ont √©t√© export√©s, on importe ce que l'on souhaite en utilisant des accolades et en indiquant le chemin vers le module √† utiliser.

```js
const¬†{¬†users,¬†authorize¬†}¬†=¬†require('../utils/auths');
```

#### b.3.4.2) Import d'un package
Il est aussi possible d'importer des objets de packages offerts par la communaut√© via votre gestionnaire de package.  
Pour ce faire, il est juste n√©cessaire d'indiquer le nom du package lors de l'import.

Si un seul objet est export√© par un package, voici un exemple de comment le r√©cup√©rer :

```js
//¬†module¬†integrated¬†to¬†the¬†runtime¬†environment
const¬†http¬†=¬†require('http');
//¬†module¬†following package installation
const¬†shortid¬†=¬†require('shortid');
```

## <a id="b4"></a> b.4) Introduction aux packages
### b.4.1) Introduction
Dans le cadre du d√©veloppement d'IHM modernes, au module 2, nous avons d√©couvert le gestionnaire de packages de Node.js. Nous allons r√©sumer les concepts importants ci-dessous.

### b.4.2) Gestionnaire de packages
**npm** est le gestionnaire de packages de Node.js. 

On peut faire des recherches de packages qui serait utiles √† nos application web sur [npmjs.com](https://www.npmjs.com/) [[R.48]](/references/#r48).

### b.4.3) Fichier de configuration d'un projet
Tous les packages associ√©s √† une app, ses d√©pendances, sont donn√©es dans le fichier : **package.json**.

C'est le fichier qui d√©crit la configuration d'un projet JS.

On peut manuellement cr√©er ce fichier √† l'aide de la commande **`npm init`** si l'on souhaite quelque chose de plus interactif ou **`npm init -y`** si l'on souhaite un fichier avec le minimum autog√©n√©r√©.

Voici un exemple de fichier **package.json** :

```json
{
  "name": "api2",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },
  "nodemonConfig": {
    "ignore": [
      "data/*"
    ],
    "exec": "npm run lint && node"
  },
  "dependencies": {
    "cookie-parser": "~1.4.4",
    "debug": "~2.6.9",
    "express": "~4.16.1",
    "morgan": "~1.9.1"
  },
  "devDependencies": {
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "nodemon": "^2.0.19",
    "prettier-airbnb-config": "^1.0.0"
  },
  "author": "e-Baron"
}
```

Lors de l'installation d'un package, celui-ci s'ajoute √† la liste des d√©pendances.  
Ainsi, si des d√©veloppeurs trouvent votre projet sur Git, ils n'auront qu'√† ex√©cuter **`npm i`** afin d'installer toutes les d√©pendances.

C'est dans le r√©pertoire **node_modules** que toutes les d√©pendances seront install√©es.  
Ces d√©pendances peuvent √™tre tr√®s volumineuses. C'est donc important de ne jamais mettre ce dossier sur vos web repository, via Git.  
Pour ce faire, n'oubliez pas d'inclure un fichier **.gitignore** dans vos repos pour ignore **node_modules**.

**package.json** indique les scripts de d√©marrage, en fonction de la fa√ßon dont nous souhaitons d√©marrer l'application.

```json
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },  
```

Au regard de cette configuration, on peut d√©marrer l'application √† l'aide de **`npm start`** ou **`npm run start`**, ce qui ex√©cutera le script **`./bin/www`** √† l'aide de **node**.  
On pourrait aussi d√©marrer l'application √† l'aide de **`npm run dev`**, ce qui d√©marrerait l'application √† l'aide de **nodemon**, un outil permettant de monitorer les changements de fichiers et de red√©marrer automatiquement le serveur en cas de changement.

NB : nous verrons plus tard cet outil **nodemon** pour simplifier le d√©veloppement.

### b.4.4) Installer un package
Pour installer un package (ou une d√©pendance), il suffit de faire : **`npm i nomDuPackage`** ou **`npm install nomDuPackage`**.

### b.4.5) D√©pendances install√©es
On a vu que **`npm i`** permet d'installer toutes les d√©pendances se trouvant dans **package.json**, ainsi que toutes les d√©pendances de ces d√©pendances...

L'arbre exact des d√©pendances install√©es, num√©ro de version..., se trouve dans **package-lock.json**. Ce fichier est g√©n√©r√© automatiquement pour chaque op√©ration modifiant **node_modules** ou **package.json**.

‚ö° Si un fichier **package-lock.json** est compris dans un repo, lorsque vous introduirez **`npm i`** pour installer toutes les d√©pendances, npm installera les m√™mes versions que celles se trouvant dans **package-lock.json**. Cela peut poser des probl√®mes si votre environnement Node.js est en version diff√©rente. En cas de souci, pensez √† effacer le r√©pertoire **node_modules** et le fichier **package-lock.json** avant de relancer l'installation de toutes les d√©pendances.

### b.4.6) Localisation d'un module ou package par Node
Node va chercher dans tous les chemins sp√©cifi√©s dans **module.paths** : **node_modules**, **.**... lorsque **`required()`** est appel√©.

### b.4.7) Mise √† jour des packages vers leur derni√®re version
La mise √† jour de toutes les d√©pendances peut parfois amener √† des gros soucis.

Vous pouvez tenter de mettre √† jour tous vos package en suivant la documentation de Node.js :
[Update all the Node.js dependencies to their latest version](https://nodejs.dev/learn/update-all-the-nodejs-dependencies-to-their-latest-version) [[R.49]](/references/#r49)

Mais attention, certains packages parfois subissent des "breaking changes", ce qui impose que vous deviez faire migrer votre code avant que celui-ci soit fonctionnel.

Nous vous recommandons donc, si vous rencontrer un probl√®me lors de la mise √† jour de tous vos packages d'un coup, de revenir √† la situation initiale, et de faire l'upgrade de chaque package list√© dans **package.json** individuellement.

# <a id="c"></a> c) Introduction √† Express
## <a id="c1"></a>  c.1) Introduction
Voici le moto du framework Express: "Fast, unopinionated, minimalist web framework for Node.js" [Express](https://expressjs.com/) [[R.50]](/references/#r50).

Express est un framework qui permet de rapidement cr√©er des applications en Node.js. 

Il est possible de cr√©er une application Express soit "from scratch", soit √† partir d'un boilerplate.

Dans le cadre de ce cours, nous allons plut√¥t utiliser des boilerplates pour g√©n√©rer des applications. N√©anmoins, il est int√©ressant de voir comment cr√©er une application "from scratch".

## <a id="c2"></a> c.2) Cr√©er une application Express "from scratch"
Il faut d'abord cr√©er un r√©pertoire pour votre application.

Au sein de votre repo **web2**, veuillez cr√©er le r√©pertoire **/tutorials/express-static-file-server**.

Veuillez, via le terminal, entrer dans ce r√©pertoire.

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **/tutorials/express-static-file-server**.

Dans ce r√©pertoire, veuillez g√©n√©rer le fichier de configuration du projet (**package.json**) : **`npm init`**.  
Veuillez r√©pondre aux questions pour configurer le point d'entr√©e de l'application comme √©tant le script **index.js**.

Veuillez configurer le script de d√©marrage de votre application en ajoutant cette ligne au sein de **package.json** :

```json {2}
  "scripts": {
    "start": "node index.js",
```

Ainsi, notre application pourra d√©marrer √† l'aide de la commande **`npm start`**.

A ce stade-ci, voil√† √† quoi devrait ressembler votre **package.json** :

```json
{
  "name": "express-static-file-server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "yourName",
  "license": "ISC"
}
```

Veuillez installer Express, son package : 

```bash
npm i express
```

Nous allons cr√©er un simple serveur de fichiers statiques √† l'aide du middleware **express.static**, afin de servir tous les fichiers qui se trouveront dans le r√©pertoire **public**.

Tout d'abord, t√©l√©chargez ce zip : <LinkFile name="public.zip" target="_blank" download>fichiers statiques</LinkFile>.

Veuillez d√©sarchiver ce r√©pertoire dans votre projet afin d'avoir les fichiers statiques qui seront partag√©s par votre serveur au sein de **/public**.   
V√©rifiez bien que vous n'avez qu'un seul r√©pertoire **/public** et pas un **/public/public**.

Il ne reste plus qu'√† cr√©er le serveur. Veuillez cr√©er le fichier **/index.js** et y ajouter ce code :

```js
const express = require('express');
const app = express();

app.use(express.static('public'));

const PORT = 7777;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

On voit que juste cette ligne permet la mise en place d'un serveur de fichier statique, via le middleware **express.static** :

```js
app.use(express.static('public'));
```

Et pour d√©marrer un serveur web qui √©coute sur le port **7777**, ces lignes sont suffisantes :
```js
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

Veuillez lancer l'application en tapant cela dans votre terminal au sein du r√©pertoire du projet :

```bash
npm start
```

Pour acc√©der au serveur de fichiers, vous pouvez le faire via un browser : [http://localhost:7777](http://localhost:7777)

Si tout se passe bien, vous devriez avoir acc√®s au site de la pizzeria d√©velopp√© au module 1 de ce cours.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**express-static-file-server**".

En cas de souci, vous pouvez acc√©der au code de cette d√©mo ici :
[express-static-file-server](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/express-static-file-server/).

## <a id="c3"></a> c.3) Cr√©er une application Express via un g√©n√©rateur
Le g√©n√©rateur d'applications **express-generator** permet de g√©n√©rer le boilerplate d'une application Express de base.

A l'aide du g√©n√©rateur d'applications Express, vous allez cr√©er une application Express sans "view engine" car nous n'allons pas faire du Server Side Rendering dans le cadre de ce cours.

Veuillez ouvrir un terminal au sein de VS Code au niveau du r√©pertoire **/tutorials**.

Ensuite, cr√©ez une application nomm√©e **basic-generated-app** en tapant :

```bash
npx express-generator --no-view basic-generated-app
```

**npx** permet de directement ex√©cuter un package en mode de commandes en installant une copie locale et temporaire de ce package (et de ses d√©pendances).

Veuillez installer les d√©pendances de votre app et la d√©marrer :

```bash
cd basic-generated-app
npm i 
npm start
```

Si vous copier / coller le contenu du r√©pertoire **/public** du tutoriel pr√©c√©dent dans le r√©pertoire **public** g√©n√©r√©, l'application fournira le m√™me r√©sultat que la pr√©c√©dente, mais sur un port diff√©rent : [http://localhost:3000](http://localhost:3000).

Nous allons d√©couvrir en d√©tails ce qui a √©t√© g√©n√©r√© par **express-generator** un peu plus tard.

Actuellement, on remarquera : 
- le point d'entr√©e de l'application est **./bin/www** au regard de **package.json**;
- que **./bin/www** d√©marre un serveur web sur le port **3000** en lui demandant de s'occuper de d√©marrer tous les middlewares en lui passant tout ce qui est export√© de **app.js**.
- **app.js** met aussi √† disposition un serveur de fichier statiques servant le contenu du r√©pertoire **public**.

Avant d'aller dans les d√©tails d'Express que nous souhaitons utiliser pour d√©velopper des services web de type RESTful, nous allons voir ce que nous entendons par RESTful.

# <a id="d"></a> d) Introduction aux RESTful API
## <a id="d1"></a> d.1) Introduction
**REST** vient de **RE**presentational **S**tate **T**ransfer : c'est un style architectural pour construire des applications web extensibles, o√π les client et serveurs sont s√©par√©s.

Dans une application REST, une **interface uniforme** (ou API) est d√©finie afin de permettre √† des applications de coop√©rer.

Toute application REST se doit d'√™tre **stateless** : il n'y a pas d'enregistrement du contexte d'une session sur le serveur pour comprendre une requ√™te d'un client.  
Ainsi, les requ√™tes clientes ne d√©pendent pas d'un historique de requ√™tes, elles sont autoportantes.

Une RESTful API met √† disposition des **op√©rations** sur des **ressources** via :
- des **URI** ; il y a donc une adresse unique pur chaque ressource ;
- des **m√©thodes HTTP** (GET, POST, DELETE, PATCH, PUT) repr√©sentant les op√©rations possibles (CRUD, op√©rations de type Create, Read, Update ou Delete) ;
- des **repr√©sentations** des ressources compr√©hensibles tant par les clients que les serveurs ; les ressources sont repr√©sent√©es par leur "Media type" : **JSON**, **XML**, **HTML**, **TXT**, **JPEG**... ; dans le cadre de ce cours, les ressources seront quasi toujours repr√©sent√©es via du **JSON**.

## <a id="d2"></a> d.2) Conventions REST

 Le type d'op√©ration CRUD (Create, Read, Update ou Delete) sur une ressource est d√©fini via la m√©thode http de la requ√™te.  
 Les op√©rations possibles sont :
  - GET = Read
  - POST = Create
  - DELETE = Delete üòâ
  - PATCH / PUT = Update
    - PATCH = Update d'une ou plusieurs propri√©t√©s de la ressources
    - PUT = Update de toutes les propri√©t√©s de la ressources, ou cr√©ation si la ressource n'existe pas
    
Voici un exemple d'application de ces conventions REST dans le cadre d'une RESTful API permettant de g√©rer des films :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **films** | GET | READ ALL : Lire toutes les ressources de la collection |
| **films?minimum-duration=value** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **films/{id}** | GET | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **films/{id}** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **films/{id}** | PUT | UPDATE ONE : Remplacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

Si cette API est h√©berg√©e √† l'URL racine **http://ilovemoovies.org**, alors nous pourrions identifier une ressource de type **films** de cette fa√ßons : **http://ilovemoovies.org/films/10**.

Pour lire cette ressource, il faudrait faire une requ√™te http de type **GET** sur cette **URL** : **http://ilovemoovies.org/films/10**.

# <a id="e"></a> d) Introduction aux RESTful API via Express
## <a id="e1"></a> e.1) Introduction
Nous avons pr√©c√©demment g√©n√©r√© une application Express √† l'aide du g√©n√©rateur d'applications.

Veuillez avoir devant vous le code de cette application car nous allons d√©couvrir le r√¥le des r√©pertoires et fichiers importants g√©n√©r√©s par **express-generator**.

Nous allons maintenant nous attarder √† comprendre les concepts associ√©s √† l'utilisation d'Express, mais en focalisant sur ceux utiles aux applications REST.

Voici comment une requ√™te faite √† une application Express est trait√©e :

<ScrollableImage name="express-flow.png" minWidth="800px" maxWidth="800px" />

<figcaption>Flux d'une requ√™te vers une application Express [R.51]</figcaption>

Dans ce flux de traitement d'une requ√™te, la responsabilit√© des d√©veloppeurs est de s'occuper de la partie "Middleware".

La grande majorit√© du code √©crit sera du "routing middleware" : notre code s'occupera de r√©pondre √† des requ√™tes clientes pour diff√©rentes URLs et m√©thodes HTTP (GET, POST...).

## <a id="e2"></a> e.2) Configuration et d√©marrage d'une application Express
On l'a d√©j√† vu, la configuration d'une application Express, comme toutes applications Node.js, est faite au sein de **package.json**.

En fonction de comment est configur√© l'application, on la d√©marrera via **npm start**, **npm run dev**...

## <a id="e3"></a> e.3) Serveur web int√©gr√©
Un serveur web int√©gr√© √† nos applications Express est d√©marr√© au sein du fichier **bin/www**.

C'est ce fichier que vous devez mettre √† jour si par exemple vous souhaitez que votre application fonctionne sur un port diff√©rent que le port par d√©faut **3000**.

Un serveur int√©gr√© est diff√©rent d'une application web offerte par un serveur standalone comme Apache, Tomcat... C'est un serveur tr√®s l√©ger d√©di√© √† votre application.

## <a id="e4"></a> e.4) Les fonctions middleware en Express
### e.4.1) C'est quoi une fonction middleware ?

Les fonctions middleware s'occupent du traitement des requ√™tes des clients et de la pr√©paration des r√©ponses :

<ScrollableImage name="middlewares.jpg" minWidth="638px" maxWidth="638px" />

<figcaption>Les fonctions Middleware et Express [R.52]</figcaption>

Une fonction du middleware a acc√®s aux objets de la requ√™te et de la r√©ponse et peut modifier la requ√™te et la r√©ponse pour ajouter, par exemple, un log, pour autoriser un utilisateur, pour parser des donn√©es Json vers des objets JS, pour servir des fichiers statiques, pour faire un traitement pour une route bien sp√©cifique...

Si une fonction du middleware ne termine pas le cycle de requ√™te-r√©ponse, elle doit appeler **`next()`** pour permettre √† d'autres fonctions qui sont dans la queue de pouvoir √™tre ex√©cut√©es.

Voici les √©l√©ments associ√©s √† l'appel d'une fonction middleware :

<ScrollableImage name="middleware-function.png" minWidth="944px" maxWidth="944px" />

<figcaption>Une fonction middleware [R.53]</figcaption>

Il existe diff√©rent types de fonctions middleware ayant diff√©rents cas d'utilisation :
- Application-level middleware : la fonction middleware est li√©e √† l'objet **app** ;
- Router-level middleware : la fonction middleware est li√©e √† un objet de type **express.router()**, elle est tr√®s similaire au "application-level middleware" ;
- Error-handling middleware : fonction de gestion des erreurs qui se d√©finit comme les fonctions app ou router level middleware, mais qui contient un quatri√®me param√®tre nomm√© **error**.
- Built-in middleware : fonctions middleware mises √† disposition par Express directement :
  - **express.static** : pour servir des assets statiques ;
  - **express.json** : pour parser le body de requ√™tes en JSON vers des objets JS ;
  - **express.urlencoded** : pour parser des requ√™tes dont le body est de type "urlencoded" (type par d√©faut des formulaires) vers des objets JS. 
- Third-party middleware : fonctions mises √† disposition par la communaut√© et installables via npm, comme par exemple la fonction middleware **cookieParser**.

Si vous souhaitez approfondir, nous vous conseillons [la documentation d'Express](https://expressjs.com/en/guide/using-middleware.html#middleware.third-party) [[R.54]](/references/#r54).

La suite fournit quelques exemples de fonctions middleware qui seront plus tard rencontr√©es dans notre code ou extraits de [[R.54]](/references/#r54).

### e.4.2) Application-level middleware : exemple
Voici une fonction middleware qui sera ex√©cut√©e √† chaque fois qu'il y a une requ√™te, quelque soit le chemin (ou path) associ√© √† la requ√™te :

```js
var¬†express¬†=¬†require('express');
var¬†app¬†=¬†express();
app.use((req,¬†res,¬†next) =>¬†{
¬†¬†console.log('Time:',¬†Date.now());
¬†¬†next();
});
```

### e.4.3) Router-level middleware : exemple

```js
var¬†router¬†=¬†express.Router();

router.use((req,¬†res,¬†next)¬†=> {
¬†¬†console.log('Time:'',¬†Date.now());
¬†¬†next();
});

router.get('/',(req,¬†res,¬†next)¬†=> {
¬†¬†return¬†res.json(menu);
});
```

La premi√®re fonction middleware ne contient pas de m√©thode HTTP, ni de chemin, elle s'applique donc √† toutes les routes associ√©es au router.

```js
var pizzaRouter = require('./routes/pizzas');
app.use('/pizzas', pizzaRouter);
```

Si le router est utilis√© de cette fa√ßon, la premi√®re fonction s'applique donc √† toutes les routes qui commencent par '/pizzas'.

La deuxi√®me fonction middleware s'appliquent seulement aux requ√™tes de type GET sur la route (ou le chemin) '/pizzas' (√©quivalent de la route '/pizzas/').

### e.4.4) Error-handling middleware : exemple
Ce type de middleware est √† d√©finir apr√®s tous les middlewares pouvant g√©n√©rer une erreur et est appel√© via **`next(err)`** dans une fonction middleware o√π un souci est d√©tect√©.

Voici la d√©finition d'un "error handler" :

```js
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
});
```

Attention, il y a bien 4 param√®tres au lieu des 3 habituels pour les autres types de fonctions middleware.

### e.4.5) Built-in middleware & third-party middleware : exemple

```js
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var app = express();

app.use(logger('dev')); //¬†HTTP request logger
app.use(express.json()); //¬†Parse requests with JSON payloads
app.use(express.urlencoded({ extended: false })); //¬†Parse requests with URL-
                                                  // encoded payload 
app.use(cookieParser()); //¬†Parse cookie header (req.cookies)
app.use(express.static(path.join(__dirname, 'public'))); //¬†Serve static assets
```

## <a id="e5"></a> e.5) D√©finition d'une route en Express
### e.5.1) D√©finition d'une route
Le "Routing", ou routage, contr√¥le la r√©ponse √† une requ√™te client pour un **endpoint** / **URI** / **PATH** et une m√©thode HTTP.

On va d√©finir une route soit sur l'objet **app**, soit sur un **router**.  
Un objet de type **router** permet de regrouper toutes les routes associ√©es √† un type de ressources.

On d√©finit une route de cette fa√ßon : **app.** ou **router.**  **METHOD(PATH, MIDDLEWARE_FUNCTION)**.

üëç Dans notre cours, nous vous recommandons d'organiser vos routes par type de ressources et donc de mettre en place un router.

### e.5.2) Cr√©ation d'un projet
Nous allons maintenant r√©aliser un tutoriel pour cr√©er notre toute premi√®re RESTful API.  
Nous allons cr√©er une API pour permettre √† notre site web de la pizzeria de b√©n√©ficier d'op√©rations sur des ressources de type "pizzas".

Dans votre repo **web2**, veuillez cr√©er le r√©pertoire **/tutorials/pizzeria/api**.

Veuillez ouvrir un terminal au niveau de ce r√©pertoire.

Dans ce r√©pertoire, veuillez g√©n√©rer une application express nomm√©e **basic**.  
Pour ce faire :

```bash
npx express-generator --no-view basic
```

Veuillez installer les d√©pendances :
```bash
cd basic
npm i
```

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **/tutorials/pizzeria/api/basic** (ou **/web2/tutorials/pizzeria/api/basic** si l'on consid√®re le nom du r√©pertoire du repo).

Nous allons d√©velopper des RESTful API qui ne poss√®dent pas de serveur de fichiers statiques.  
On n'a donc pas besoin d'avoir un r√©pertoire **/public** ni d'un serveur statique.  
On peut donc effacer le r√©pertoire **/public** et supprimer le middleware de serveur de fichiers statiques au sein de **/app.js** : 

```js
app.use(express.static(path.join(__dirname, 'public'))); 
```


## <a id="e6"></a> e.6) Op√©ration de lecture
Nous souhaitons par commencer √† d√©velopper une op√©ration permettant de lire toutes les ressources de type "pizzas". En effet, nous aimerions plus tard que notre IHM re√ßoive de notre API le menu des pizzas.

Veuillez cr√©er un router pour traiter des ressources **/pizzas** au sein de **/routes/pizzas.js**.  
Le plus simple est d'adapter **indexRouter** dans **app.js** en **pizzaRouter** et **/routers/index.js** en **/routes/pizzas.js**.  
Il est aussi possible de partir de rien et de cr√©er **pizzaRouter** dans **app.js** et **/routes/pizzas.js**.

Pour l'op√©ration de lecture de toutes les pizzas, selon les conventions REST, il faut faire une requ√™te de type **GET /pizzas**.  
**/routes/pizzas.js** doit donc offrir une route renvoyant toutes les pizzas qui existent dans le menu.   
Pour d√©marrer, nous souhaitons une application basique qui ne g√®re pas la persistance des donn√©es. Le menu est donc un Array d'objets, dont chaque objet repr√©sente une pizza.

Notre op√©ration de lecture de pizza va renvoyer du JSON au client, c'est √† dire une repr√©sentation textuelle du menu. Nous verrons plus tard ce qu'est r√©ellement le JSON. A ce stade-ci, il est suffisant de conna√Ætre la fonction d'Express qui permet √† un objet JS de circuler sur le r√©seau : **res.json()**.

Voici le code du router **/routes/pizzas.js** :
```js
var express = require('express');
var router = express.Router();

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

// Read all the pizzas from the menu
router.get('/', (req, res, next) => {
  console.log('GET /pizzas');
  res.json(MENU);
});

module.exports = router;
```

Et voici le code de **app.js** (les parties modifi√©es sont surlign√©es) :

```js numbered {6,16}
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var pizzaRouter = require('./routes/pizzas');
var usersRouter = require('./routes/users');

var app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/pizzas', pizzaRouter);
app.use('/users', usersRouter);

module.exports = app;
```

Notons que nous pourrions effacer le router s'occupant des ressources de type "users", mais nous pr√©f√©rons le garder car plus tard nous souhaiterons g√©rer l'authentification d'utilisateurs.

Veuillez d√©marrer l'API (par d√©faut elle est configur√©e sur le port 3000 au sein de **bin/www**) :

```bash
npm start
```

Pour consommer l'op√©ration de lecture via un browser, nous pouvons lire toutes les ressources de type "pizzas" ici :
[http://localhost:3000/pizzas](http://localhost:3000/pizzas)

## <a id="e7"></a> e.7) Chemin et param√®tres de route
Les "route parameters" sont des segments d'une URL qui sont utilis√©s pour capturer une valeur sp√©cifi√©e √† leur position dans l'URL. On r√©cup√®re ces param√®tres via l'objet **req.params**.

Pour notre pizzeria, nous souhaitons pouvoir lire une pizza identifi√©e par son **id**.

Nous allons donc ajouter le param√®tre de route **id**.  
En respect des conventions REST, un client, pour faire appel √† cette op√©ration, devra faire une requ√™te du genre : **GET /pizzas/2**.

Voici la nouvelle route permettant de traiter de cette op√©ration, √† ajouter dans le router **/routes/pizza.js** :
```js
// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  console.log(`GET /pizzas/${req.params.id}`);

  const indexOfPizzaFound = MENU.findIndex((pizza) => pizza.id == req.params.id);

  if (indexOfPizzaFound < 0) return res.sendStatus(404);

  res.json(MENU[indexOfPizzaFound]);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire la ressource de type "pizzas" identifi√©e par **2** dans le menu ainsi :
[http://localhost:3000/pizzas/2](http://localhost:3000/pizzas/2)

Le browser fait bien une requ√™te du genre : **GET /pizzas/2**.

Le param√®tre de la route "2" est r√©cup√©r√© dans l'URL de la route par Express et est offert via **`req.params.id`**. 

N'h√©sitez pas √† faire une requ√™te pour un identifiant n'existant pas de le menu pour voir ce qui se passe : [http://localhost:3000/pizzas/666](http://localhost:3000/pizzas/666)


## <a id="e8"></a> e.8) Chemin et param√®tres de requ√™te
Les "query parameters" sont des param√®tres qui peuvent √™tre ajout√©s √† une URL.  
On r√©cup√®re ces param√®tres via l'objet **req.query**.

Pour notre pizzeria, nous souhaitons pouvoir lire toutes les ressources de type "pizzas" tri√©es par ordre ascendant ou descendant du titre.

En respect des conventions REST, un client, pour faire appel √† cette op√©ration, devra faire une requ√™te du genre : **GET /pizzas?order=title** pour le tri ascendant ou **GET /pizzas?order=-title** pour le tri descendant .

Il n'y a donc pas de nouvelle route √† ajouter ici. En effet, √ßa reste une requ√™te de type GET sur la route "/pizzas". 

Veuillez donc mettre √† jour **/routes/pizza.js** pour la lecture de toutes les pizzas :
```js
/* Read all the pizzas from the menu
   GET /pizzas?order=title¬†:¬†ascending order¬†by¬†title
¬†  GET /pizzas?order=-title¬†:¬†descending order¬†by¬†title
*/
router.get('/', (req, res, next) => {
  const orderByTitle =
    req?.query?.order?.includes('title')
      ? req.query.order
      : undefined;
  let orderedMenu;
  console.log(`order by ${orderByTitle ?? 'not requested'}`);
  if (orderByTitle)
    orderedMenu = [...MENU].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  console.log('GET /pizzas');
  res.json(orderedMenu ?? MENU);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire toutes les ressources de type "pizzas" tri√©e par leur titre de mani√®re descendante ainsi :
[http://localhost:3000/pizzas?order=-title](http://localhost:3000/pizzas?order=-title).

N'h√©sitez pas √† tester d'autres tris.

üí≠ Est-ce qu'il y a un morceau de code que vous ne comprenez pas dans ce code-ci et cela vous g√™ne ? Si oui, vous trouverez plus d'info ici : [f.2) Spread operator au niveau d'un array](#f2).  
Si non, c'est OK de ne pas comprendre tous les √©l√©ments du code √† ce stade-ci.

## <a id="e9"></a> e.9) Op√©ration de cr√©ation & parsing du body
Nous souhaitons d√©velopper une op√©ration permettant de cr√©er une ressource de type "pizzas".  
Selon les conventions REST, il faut faire une requ√™te de type **POST /pizzas** qui offre une repr√©sentation de la ressource √† cr√©er. La repr√©sentation utilis√©e est le JSON que nous verrons plus en d√©tails plus tard.  
Si nous souhaitons cr√©er une ressource dont le titre est "Magic Green" et le contenu est "Epinards, Brocolis, Olives vertes, Basilic", la repr√©sentation de la ressource √† cr√©er sera la suivante :
```json
{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Selon les conventions REST, une requ√™te de cr√©ation est de type POST et contient ses param√®tres 
au sein du body de la requ√™te.

**/routes/pizzas.js** doit offrir une nouvelle route permettant d'ajouter une nouvelle pizza au menu, qui est un array d'objets. Une nouvelle pizza doit donc √™tre ajout√©e √† une variable, un array, qui est contenu dans la m√©moire vive de votre machine.  
Lorsque l'ajout d'une pizza au menu a r√©ussi, nous souhaitons renvoyer la repr√©sentation de la nouvelle ressource au client. Ainsi, le client aura notamment acc√®s √† l'id de la pizza cr√©√© par l'API.

Voici le code du router **/routes/pizzas.js** pour la nouvelle op√©ration, veuillez le rajouter dans votre application :
```js
// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const lastItemIndex = MENU?.length !== 0 ? MENU.length - 1 : undefined;
  const lastId = lastItemIndex ? MENU[lastItemIndex]?.id : undefined;
  const nextId = lastItemIndex !== 0 ? lastId + 1 : 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  MENU.push(newPizza);

  res.json(newPizza);
});
```

La repr√©sentation de la ressource √† cr√©er est pars√©e dans l'objet **req.body** gr√¢ce √† la fonction middleware **express.json()** appel√©e dans **/app.js** :
```js
app.use(express.json());
```

Il est donc important de ne pas retirer cette ligne lorsque l'on cr√©e une RESTful API.


OK, c'est bien, mais comment tester ce nouveau code ?

Le browser permet de facilement cr√©er des requ√™tes de type GET, mais pas des requ√™tes de type POST...   
Nous avons donc besoin d'un client l√©ger permettant de faire des requ√™tes HTTP.

## <a id="e10"></a> e.10) Client REST
### e.10.1) Introduction
Dans le cadre de ce cours, tout comme g√©n√©ralement dans un environnement professionnel, nous souhaitons pouvoir d√©velopper une API ind√©pendamment du d√©veloppement d'une IHM.

En effet, cela prendrait trop de temps de devoir d√©velopper un frontend (HTML / JavaScript / CSS) pour tester nos API.

Nous allons donc utiliser un client l√©ger permettant de faire des requ√™tes √† nos API.  
Il en existe de nombreux, comme REST Client [[R.55]](/references/#r55) ou Postman [[R.56]](/references/#r56).

Pour ce cours, nous vous pr√©sentons et recommandons d'utiliser REST Client pour √©crire et ex√©cuter vos requ√™tes HTTP.

### e.10.2) REST Client
Dans le cadre de ce cours, nous utilisons REST Client [[R.55]](/references/#r55) de Visual Studio Code pour tester nos API.

Pour installer REST Client au sein de VS Code, veuillez cliquer sur l'onglet **Extensions**. 

Recherchez l'extension **REST Client** et cliquez sur **Install**.

Quelques notions pour utiliser REST Client :
- Il faut cr√©er un fichier **.http** (ou **.rest**) contenant les requ√™tes vers vos RESTful APIs.  
NB : Il est appropri√© de cr√©er un fichier par par type de ressources.
- Chaque requ√™te est introduite par **###** (3 "**#**"" ou plus) ; voici la requ√™te permettant de lire toutes les pizzas :
```http
### Read all pizzas
GET http://localhost:3000/pizzas
```
- Pour ex√©cuter une requ√™te, il suffit de cliquer sur **Send Request**.
- Lorsqu'on envoie des donn√©es au format JSON, il est important d'avoir un espace avant les accolades (avant le "**&#123;**" ).
- On peut d√©finir des "**File variables**" via ce genre de syntaxe : **@baseUrl = http://localhost:3000**.
- Pour utiliser la variable **baseUrl**, il suffit de la mettre entre double accolades. Par exemple, voici la requ√™te permettant de lire toutes les pizzas :  
```http
### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas
```

Nous allons maintenant tester l'API de la pizzeria que nous avons cr√©√©e pour toutes ses op√©rations.

Au sein de VS Code, dans votre projet **/tutorials/pizzeria/api/basic**, veuillez cr√©er un r√©pertoire nomm√© **REST Client**. Dans ce r√©pertoire, veuillez cr√©er un fichier nomm√© **pizzas.http**.

Dans **pizzas.http**, veuillez ajouter cette requ√™te pour la lecture de toutes les pizzas et ex√©cutez la : 
```http
### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas
```

Est-ce que cela fonctionne bien ?  Avez vous bien d√©marr√© votre API ?  
Vous devriez obtenir le m√™me r√©sultat que si vous acc√©diez √† votre API √† l'aide du browser.

Au sein de **pizzas.http**, veuillez ajouter ces deux requ√™tes pour la lecture de toutes les pizzas en les triant selon leur titre :
```http
### Read all pizzas sorted by title (ascending)
GET {{baseUrl}}/pizzas/?order=+title

### Read all pizzas sorted by title (descending)
GET {{baseUrl}}/pizzas/?order=-title
```

Veuillez ex√©cuter ces deux requ√™tes.

Il semble que nous sommes pr√™t pour cr√©er une requ√™te appelant l'op√©ration de cr√©ation d'une pizza.

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour la cr√©ation d'une pizza :
```http
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

On remarque qu'il est important de mettre une ligne vide avant les accolades repr√©sentant le body de la requ√™te.  N'h√©sitez pas √† tester cette requ√™te avec ou sans la ligne vide pour y croire.

üí≠ Comment tester que l'op√©ration de cr√©ation a fonctionn√©e ?

Et bien il suffit d'ex√©cuter l'op√©ration de lecture de toutes les pizzas üòé !
Si la nouvelle ressource appara√Æt, c'est qu'elle a bien √©t√© cr√©√©e !
Faites le test.

## <a id="e11"></a> e.11) R√©pondre avec un code de statut HTTP
On ne peut pas toujours renvoyer du JSON suite √† une requ√™te client ainsi qu'un code HTTP correspondant au fait que tout est OK ("200 OK").

Quand vous ex√©cutez cette requ√™te :
```http
### Read all pizzas with File variable
GET {{baseUrl}}/pizzas
```

Vous faites appel √† l'op√©ration de lecture de toutes les pizzas. La derni√®re ligne de cette op√©ration est la suivante :
```js
res.json(orderedMenu ?? MENU);
```

En fait, la fonction **json** renvoie une r√©ponse au format JSON, mais de plus, elle renvoie un "status code" **200** indiquant au client que tout s'est bien pass√©.

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour tenter de cr√©er une pizza en oubliant un param√®tre :
```http
### Create a pizza which lacks a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Veuillez ex√©cuter cette requ√™te. Que se passe-t-il ?  
On r√©cup√®re un code d'erreur "400 Bad Request".

En effet, lorsqu'on omet un param√®tre dans la repr√©sentation de la ressource √† cr√©er, voici les lignes de code amenant au renvoi du code d'erreur 400 au sein de **pizzas.js** :
```js numbered {3,4,8}
// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const lastItemIndex = MENU?.length !== 0 ? MENU.length - 1 : undefined;
  const lastId = lastItemIndex ? MENU[lastItemIndex]?.id : undefined;
  const nextId = lastItemIndex !== 0 ? lastId + 1 : 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  MENU.push(newPizza);

  res.json(newPizza);
});
```

Le client est donc bien inform√© qu'il y a eu un probl√®me lors de l'ex√©cution de l'op√©ration.   
Il pourrait par exemple utiliser cette information pour pr√©senter un message d'erreur au niveau d'une IHM.

Voici les grandes cat√©gories de "status codes" :
- R√©ponses informatives : **100-199**
- R√©ponses en cas de succ√®s : **200-299**
- Redirections : **300-399**
- Erreurs du client : **400-499**
- Erreurs du serveur : **500-599**

Voici les "status codes" que nous allons g√©n√©ralement utiliser :
- **200 OK** : tout s'est bien pass√©, Express ajoute ce code automatiquement pour nous quand nous utilisons une m√©thode comme **res.json()**.
- **400 Bad Request** : pour indiquer au client que la requ√™te contient des param√®tres non valides ou n'est pas compl√®te.
- **401 Unauthorized** : pour indiquer au client qu'il doit s'authentifier pour acc√©der √† cette op√©ration. On renvoie aussi ce code d'erreur quand un client fournit un mauvais username ou password.
- **403 Forbidden** : le client est connu du serveur, mais il n'a pas les privil√®ges pour acc√©der √† cette op√©ration (par exemple, le client n'est pas admin et tente d'acc√©der √† une op√©ration seulement accessible √† un admin).
- **404 Not Found** : la ressource demand√©e n'existe pas, bien que l'URL semble valide.
- **409 Conflict** : l'√©tat du serveur entre en conflit avec la requ√™te. Par exemple, la requ√™te demande de cr√©er un utilisateur qui existe d√©j√†.
- **500 Internal Server Error** : le serveur a rencontr√© une erreur qu'il ne peut pas r√©gler. Par exemple, le serveur de base de donn√©es ne r√©pond pas et ne permet donc pas d'acc√©der aux ressources.

## <a id="e12"></a> e.12) Op√©ration de suppression
Nous souhaitons d√©velopper une op√©ration permettant de supprimer une ressource de type "pizzas" √† l'aide de son identifiant.  
Selon les conventions REST, il faut faire une requ√™te de type **DELETE /pizzas/{id}** contenant l'identifiant de la ressource √† supprimer au sein de l'URL comme "path parameter".

Une op√©ration de suppression ne contient donc pas de body et est de type DELETE. 

Voici le code du router **/routes/pizzas.js** pour la nouvelle op√©ration, veuillez la rajouter dans votre application :
```js
// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  console.log(`DELETE /pizzas/${req.params.id}`);

  const foundIndex = MENU.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const itemsRemovedFromMenu = MENU.splice(foundIndex, 1);
  const itemRemoved = itemsRemovedFromMenu[0];

  res.json(itemRemoved);
});
```

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour supprimer la pizza poss√©dant l'identifiant "2" :
```http
### Delete pizza identified by 2
DELETE {{baseUrl}}/pizzas/2
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la pizza a bien √©t√© supprim√©e.

## <a id="e13"></a> e.13) Op√©ration de modification
Nous souhaitons d√©velopper une op√©ration permettant de modifier une ressource de type "pizzas" √† l'aide de son identifiant et de nouvelles valeurs pour ses propri√©t√©s.  
Selon les conventions REST, comme on accepte de modifier que certaines des propri√©t√©s d'une pizza, qu'il ne faut pas fournir toutes les propri√©t√©s d'une pizza, il faut faire une requ√™te de type **PATCH /pizzas/{id}** contenant 
l'identifiant de la ressource √† supprimer au sein de l'URL comme "path parameter" ainsi que les nouvelles donn√©es au sein du body de la requ√™te.

Si nous souhaitons modifier une ressource identifi√©e par 6 en fournissant un nouveau titre "Magic Green 2", la repr√©sentation des donn√©es de la ressource √† modifier sera la suivante :
```json
{
    "title":"Magic Green 2"
}
```

Selon les conventions REST, la requ√™te de modification est de type PATCH et contient ses param√®tres au sein du body de la requ√™te.

Voici le code du router **/routes/pizzas.js** pour la nouvelle op√©ration, veuillez la rajouter dans votre application :
```js
// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  console.log(`PATCH /pizzas/${req.params.id}`);

  const title = req?.body?.title;
  const content = req?.body?.content;

  console.log('POST /pizzas');

  if ((!title && !content) || title?.length === 0 || content?.length === 0) return res.sendStatus(400);

  const foundIndex = MENU.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const updatedPizza = {...MENU[foundIndex], ...req.body};

  MENU[foundIndex] = updatedPizza;

  res.json(updatedPizza);
});
```

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour modifier la pizza poss√©dant l'identifiant "6" :
```http
### Update the pizza identified by 6
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json

{
    "title":"Magic Green 2"
}
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la pizza a bien √©t√© modifi√©e.

üí≠ Cela ne fonctionne pas ?  
Avez vous pr√©c√©demment ex√©cut√© la requ√™te permettant de cr√©er une sixi√®me pizza.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**api-basic**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici : [api-basic](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/basic).

# <a id="f"></a> f) Spread operator
## <a id="f1"></a> f.1) Spread operator au niveau d'un objet
üí≠ Avez-vous observ√© un morceau de code inconnu au niveau de l'op√©ration de modification, dans le router ?
```js
const updatedPizza = {...MENU[foundIndex], ...req.body};
```

Le **spread operator** est tr√®s utile en JS, ce sont les **"..."**.  
Ici, nous cr√©ons un nouvel objet en int√©grant deux objets : **`MENU[foundIndex]`** et **`req.body`**.  
Le **spread operator** permet de faire une "Shallow copy", ou copie peu profonde, d'une pizza du menu, √† l'aide de **`...MENU[foundIndex]`**.  
Cela reprend toutes les propri√©t√©s de la pizza identifi√©e par **`foundIndex`**.  
Ensuite, nous rempla√ßons les propri√©t√©s existantes de cette pizza par les propri√©t√©s donn√©es dans **`req.body`** √† l'aide de **`...req.body`**.  

## <a id="f2"></a> f.2) Spread operator au niveau d'un array
Au niveau de l'op√©ration de lecture de toutes les pizzas, nous avons rencontr√© le **spread operator**.
```js
orderedMenu = [...MENU].sort((a, b) => a.title.localeCompare(b.title));
```

En effet, lorsque nous faisons un tri du menu, nous souhaitons le faire sur une copie de celui-ci.  
üí≠ Mais pourquoi le faire sur une copie ?  
Et bien, si nous autorisons √† trier l'array associ√© au MENU, lorsque nous tenterons d'ajouter une nouvelle pizza, le dernier √©l√©ment de l'array ne contiendra plus le dernier id (ou l'id le plus haut) !  
Comme la fonction **sort** modifie l'array sur lequel la m√©thode est appel√©e, nous travaillons sur une copie de cet array : **`[...MENU]`** cr√©e un nouveau tableau contenant tous les √©l√©ments du **MENU**.

## <a id="f3"></a> f.3) Conclusion
Le **spread operator** est incroyablement puissant, il permet d'√©crire du code concis et lisible.  
Il est utilis√© dans les objets, les arrays, ainsi que comme param√®tre de fonction.  

N'h√©sitez pas √† consulter la [documentation de MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) [[R.57]](/references/#r57) pour en savoir plus.

# <a id="g"></a> g) Exercice 4.1 : Cr√©ation d'une RESTfull API non prot√©g√©e pour myMovies
Veuillez continuer le d√©veloppement de **myMovies**. Vous allez cr√©er la premi√®re version de la RESTful API de **myMovies**, sous Express, afin de mettre √† disposition toutes les op√©ration de type CRUD sur des films.


Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :
-	Veuillez cr√©er une RESTful API pour la collection de films, qui r√©ponde sur le port par d√©faut d'une application Express (3000), et qui couvre ces op√©rations :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **films** | GET | READ ALL : Lire toutes les ressources de la collection |
| **films?minimum-duration=value** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **films/{id}** | GET | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **films/{id}** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **films/{id}** | PATCH | UPDATE ONE : Mettre √† jour les propri√©t√©s de la ressource par les valeurs donn√©es dans la requ√™te, pour une ou plusieurs propri√©t√©s |

- Une ressource de type **films** doit contenir les propri√©t√©s suivantes :
  - **id** : un entier
  - **title** : titre du film (String)
  - **duration** : dur√©e du film en minutes
  - **budget** : pour informer du co√ªt qu'a cout√© la production du film, en millions
  - **link** : pour donner une URL vers la description du film (lien vers imdb, rottentomatoes ou autre)
-	Les ressources ne doivent pas persister : d√®s lors, ajoutez les donn√©es associ√©es aux films dans un array.
-	Veuillez tester toutes les fonctions de la RESTful API pour la collection de films √† l'aide du REST Client dans VS Code (extension √† installer au sein de VS Code). Veuillez ajouter vos requ√™tes au sein du fichier **films.http** dans le r√©pertoire **REST Client** du dossier associ√© √† cet exercice.

Le code de votre application web doit se trouver dans votre repository local et votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√© **/exercises/module4/4.1**.

Veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 4 : basic API**".

# <a id="h"></a> h) üç¨ Exercice 4.2 : Gestion de la pagination, de l'ordre de pr√©sentation et du filtrage de films
N'h√©sitez pas, c'est optionnel, de g√©rer de nouvelles op√©rations au sein de votre RESTful API de **myMovies** :
-	Filtrez tous les films qui commencent par une certaines cha√Ænes de caract√®res.
-	G√©rez l'ordre de pr√©sentation des films.

#### ü§ù Tips
Besoin d'inspiration pour l'aspect filtrage et la gestion de l'ordre des ressources ? [REST API Guide](https://dev.to/drminnaar/rest-api-guide-14n2) [[R.58]](/references/#r58).

Veuillez faire un **commit** de votre code avec le message suivant : "**myMovies : module 4 : ordering & filtrering**".

üç¨ Et si vraiment vous avez encore du temps et souhaitez d√©j√† approfondir les RESTful APIs, n'h√©sitez pas aussi √† impl√©menter la gestion de la pagination.