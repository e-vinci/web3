---
title: 'Module 5 : Service web persistant via JSON et architectur√©'
description: "Persistance des ressources via fichiers JSON & refactor du code d'une RESTful API"
---

# Module 5 : Service web persistant via JSON et architectur√©

Ce module vous offre principalement la persistance des ressources via des fichiers JSON et le refactoring de web services afin de faciliter la maintenabilit√© et lisibilit√© du code.

Voici les sujets trait√©s :

- a) [Introduction au JSON et persistance des donn√©es](#a)
  - a.1) [Introduction](#a1)
  - a.2) [Introduction au JSON](#a2)
  - a.3) [Communication de donn√©es en JSON](#a3)
  - a.4) [Sauvegarde de donn√©es JSON](#a4)
- b) [Am√©lioration des outils de d√©veloppement](#b)
  - b.1) [Introduction](#b1)
  - b.2) [Red√©marrage automatique au changement d'un fichier](#b2)
  - b.3) [Debugging](#b3)
  - b.4) [Autres outils de d√©veloppement](#b4)
- c) [Exercice 5.1 : Persistance de la RESTfull API pour myMovies](#c)
- d) [Refactoring √† l'aide d'un "fat model"](#d)
  - d.1) [Architectures possibles ?](#d1)
  - d.2) [Architecture Express & "fat model"](#d2)
- e) [Exercice 5.2 : Refactor de la RESTfull API pour myMovies](#e)

# <a id="a"></a> a) Introduction au JSON et persistance des donn√©es

## <a id="a1"></a> a.1) Introduction g√©n√©rale

Au module 4, nous avons d√©velopp√© notre premi√®re RESTful API.  
Nous avons implicitement d√©couvert le JSON, notamment lorsque nous avons fait des requ√™tes vers nos API.

Nous allons maintenant voir ce que permet le JSON, notamment la cr√©ation de fichiers permettant de sauvegarder des donn√©es facilement en JS.

## <a id="a2"></a> a.2) Introduction au JSON

JSON vient de **J**ava**S**cript **O**bject **N**otation.

C'est une syntaxe pour **√©changer** et **faire persister des donn√©es**.

Du JSON, c'est du texte en notation JS.

Voici les types de donn√©es qui sont valides en JSON :

- string
- number
- object
- array
- boolean
- null

‚ö° Il n'y a donc pas de **function**, **date** et **undefined**.

Voici un exemple de repr√©sentations de donn√©es en JSON qui correspond √† ce que tr√®s souvent une API renvoie, un array d'objets :

```json
[
  {
    "email": "raphael@voila.com",
    "fullname": "Raphael Baroni"
  },
  {
    "email": "jkj@herenqn.com",
    "fullname": "JK Roling"
  },
  {
    "email": "serena@gmail.com",
    "fullname": "Serena Here"
  }
]
```

## <a id="a3"></a> a.3) Communication de donn√©es en JSON

### a.3.1) S√©rialisation d'objets JS vers du JSON

#### a.3.1.1) Envoi d'une application serveur vers un client

Via Express, nous pouvons tr√®s facilement convertir un objet JS en JSON afin de l'envoyer vers une application cliente gr√¢ce √† la m√©thode **`res.json()`**.

C'est ce que nous appelons de la s√©rialisation de donn√©es, nous passons du monde "objets en m√©moire" vers du texte (ou des octets) qui vont voyager sur un r√©seau.

Le code actuel de notre RESTful API renvoyant un array de pizzas au format JSON est g√©r√© automatiquement via :

```js
res.json(orderedMenu ?? MENU);
```

Lorsque l'API renvoie **`MENU`** avec les pizzas par d√©faut, voici le JSON qui voyage sur le r√©seau :

```json
[
  {
    "id": 1,
    "title": "4 fromages",
    "content": "Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates"
  },
  {
    "id": 2,
    "title": "Vegan",
    "content": "Tomates, Courgettes, Oignons, Aubergines, Poivrons"
  },
  {
    "id": 3,
    "title": "Vegetarian",
    "content": "Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives"
  },
  {
    "id": 4,
    "title": "Alpage",
    "content": "Gruy√®re, Mozarella, Lardons, Tomates"
  },
  {
    "id": 5,
    "title": "Diable",
    "content": "Tomates, Mozarella, Chorizo piquant, Jalapenos"
  }
]
```

üí≠ La puissance du JSON peut d√©j√† s'exprimer ici. Mais comment ?

L'API renvoie un array d'objets, des pizzas, au format JSON, qui correspond en fait √† un format texte avec des conventions.  
Il est donc possible √† n'importe quelle application cliente d'utiliser ces donn√©es, quelque soit la technologie, le langage utilis√© pour d√©velopper cette application cliente.   
Ainsi, par exemple, une application Android, d√©velopp√©e en Java, pourrait consommer cette API pour afficher un menu de pizzas !

#### a.3.1.2) Envoi d'une application cliente vers un serveur

Il est possible aussi, et nous le verrons plus tard en d√©tails, de communiquer des donn√©es d'une IHM vers une API.

Nous avons d√©j√† envoy√© du JSON √† une API via REST Client.  
Voici la requ√™te envoyant, dans son body, la repr√©sentation JSON d'une ressource de type "pizzas" √† cr√©er :

```http
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Il est important de communiquer le "media type" (ou **MIME**) du corps de la requ√™te : "**application/json"**.  
Cela indique √† l'application qui est la cible de la requ√™te quelle genre d'outil elle devra utiliser pour d√©coder les donn√©es.  
Par exemple, il faut faire un traitement diff√©rent pour r√©cup√©rer des donn√©es au format JSON que pour r√©cup√©rer des donn√©es directement associ√©es √† un fichier image.

Si l'on consid√®re une IHM, il sera utile plus tard d'avoir un formulaire permettant d'ajouter des pizzas.  
Le JS associ√© √† l'IHM permettra d'envoyer les donn√©es du formulaire au format JSON, via la m√©thode **`fetch`**, vers notre RESTful API g√©rant les ressources de type pizzas.

Voici un exemple de code que vous ne devez pas encore comprendre :

```js
const options = {
  method: 'POST',
  body: JSON.stringify({
    title: title.value,
    content: content.value,
  }),
  headers: {
    'Content-Type': 'application/json',
  },
};

const response = await fetch('/api/pizzas', options);
const pizza = await response.json();
```

### a.3.2) Parsing de donn√©es JSON vers un objet JS

#### a.3.2.1) R√©ception par une application serveur

Via Express, nous pouvons tr√®s facilement convertir du JSON vers un objet JS √† l'aide du middleware **`express.json()`**.

C'est ce que nous appelons du parsing de donn√©es, ou de la d√©s√©rialisation, c'est quand nous passons du monde texte / JSON (ou des octets) vers des "objets en m√©moire".

Le code actuel de notre RESTful API r√©cup√©rant les donn√©es d'une pizza √† cr√©er est tr√®s simple :

```js
const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;
```

Automatiquement gr√¢ce √† Express et au middleware appel√© dans **apps.js** (**`app.use(express.json());`**), **`req.body`** contient un objet JS repr√©sentant toutes les donn√©es JSON qui √©taient pr√©sentes dans le body de la requ√™te cliente, comme par exemple :

```http {5-8}
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

#### a.3.2.2) R√©ception par une application cliente

Plus tard, nous verrons comment une IHM peut utiliser les donn√©es envoy√©es par une API.

La m√©thode **`fetch`** en collaboration avec la m√©thode **`json`** sur la r√©ponse d'une API permet de r√©cup√©rer et parser des donn√©es JSON vers un objet JS.  
Par exemple, cette requ√™te de cr√©ation d'une pizza parse la ressource qui a √©t√© rajout√©e c√¥t√© API au sein de la variable **`pizza`** :

```js {13}
const options = {
  method: 'POST',
  body: JSON.stringify({
    title: title.value,
    content: content.value,
  }),
  headers: {
    'Content-Type': 'application/json',
  },
};

const response = await fetch('/api/pizzas', options);
const pizza = await response.json();
```

## <a id="a4"></a> a.4) Sauvegarde de donn√©es JSON

### a.4.1) S√©rialisation d'objets JS vers du JSON

#### a.4.1.1) Application c√¥t√© serveur

La fonction JS **`JSON.stringify(objectToSerialised)`** permet de cr√©er une **string** contenant la repr√©sentation JSON de l'objet √† s√©rialiser.

C√¥t√© serveur, il est ensuite facile de sauvegarder les donn√©es JSON au sein d'un fichier.

Voici un exemple de code, une fonction, permettant √† une application Express de sauvegarder au format JSON un objet dans un fichier **.json** dont son chemin et nom complet sont indiqu√©s dans le param√®tre **filePath** :

```js
/**
 * Serialize the content of an Object within a file
 * @param {String} filePath - path to the .json file
 * @param {Array} object - Object to be written within the .json file.
 * Even if the file exists, its whole content is reset by the given object.
 */
function serialize(filePath, object) {
  const objectSerialized = JSON.stringify(object);
  fs.writeFileSync(filePath, objectSerialized);
}
```

Imaginez que, au sein du router traitant des ressources de type "pizzas", vous passiez la valeur suivante √† **filePath** :

```js
const jsonDbPath = __dirname + '/../data/pizzas.json';
serialize(jsonDbPath, MENU);
```

Cela signifie que dans le projet contenant notre API, nous allons sauvegarder le menu des pizzas au format JSON dans le fichier JSON **/data/pizzas.json**.

Ce fichier est en fait une base de donn√©es simplifi√©e !  
Nous allons prochainement voir comment r√©cup√©rer ces donn√©es au sein d'un array.

Nous allons maintenant r√©aliser un tutoriel pour rendre persistant les ressources de type "pizzas".  
Nous allons repartir de l'API cr√©√©e au module 4.

Dans votre repo **web2**, veuillez copier / coller le r√©pertoire **/tutorials/pizzeria/api/basic** et le renommer en **/tutorials/pizzeria/api/persistence**.

En cas de souci, vous pouvez t√©l√©charger le code du tutoriel pr√©c√©dent ici : [api-basic](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/basic).

Veuillez ouvrir un terminal au niveau de ce r√©pertoire.

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **/tutorials/pizzeria/api/persistence** (ou **/web2/tutorials/pizzeria/api/persistence** si l'on consid√®re le nom du r√©pertoire du repo).

Veuillez cr√©er un nouveau r√©pertoire **/utils**. Au sein de ce r√©pertoire, veuillez cr√©er le module **/utils/json.js** dans lequel vous allez ajouter ces fonctions :

```js
const fs = require('fs');

/**
 * Parse items given in a .json file
 * @param {String} filePath - path to the .json file
 * If the file does not exist or it's content cannot be parsed as JSON data,
 * use the default data.
 * @param {Array} defaultArray - Content to be used when the .json file does not exists
 * @returns {Array} : the array that was parsed from the file (or defaultArray)
 */
function parse(filePath, defaultArray = []) {
  if (!fs.existsSync(filePath)) return defaultArray;
  const fileData = fs.readFileSync(filePath);
  try {
    // parse() Throws a SyntaxError exception if the string to parse is not valid JSON.
    return JSON.parse(fileData);
  } catch (err) {
    return defaultArray;
  }
}

/**
 * Serialize the content of an Object within a file
 * @param {String} filePath - path to the .json file
 * @param {Array} object - Object to be written within the .json file.
 * Even if the file exists, its whole content is reset by the given object.
 */
function serialize(filePath, object) {
  const objectSerialized = JSON.stringify(object);
  createPotentialLastDirectory(filePath);
  fs.writeFileSync(filePath, objectSerialized);
}

/**
 *
 * @param {String} filePath - path to the .json file
 */
function createPotentialLastDirectory(filePath) {
  const pathToLastDirectory = filePath.substring(0, filePath.lastIndexOf('/'));

  if (fs.existsSync(pathToLastDirectory)) return;

  fs.mkdirSync(pathToLastDirectory);
}

module.exports = { parse, serialize };
```

L'op√©ration de s√©rialisation des donn√©es est faite via la fonction **serialize** de **/utils/json.js**. Pour se simplifier la vie et ne pas obliger les d√©veloppeurs √† devoir cr√©er manuellement un r√©pertoire qui contiendra la mini DB de pizzas (le fichier **pizzas.json** dans la suite de l'exemple), une fonction a √©t√© cr√©√©e qui s'appelle **createPotentialLastDirectory**.La fonction **serialize** fait appel √† cette fonction qui va, si n√©cessaire, cr√©er le dernier r√©pertoire donn√© dans le chemin vers le fichier JSON (le r√©pertoire **/data** dans la suite de l'exemple).

Il n'est pas int√©ressant de retenir par coeur le code donn√© dans **/utils/json.js**. Par contre, il est important que vous compreniez celui-ci, ce qu'il fait.

A pr√©sent, nous allons convertir le code du router de "pizzas" pour rendre persistant les donn√©es.    
Voici ce que nous devons faire pour les op√©rations de :
- **lecture de ressources** : il suffit de faire appel √† la fonction **`parse`** qui tentera de charger les ressources qui devraient se trouver dans le r√©pertoire **/data/pizzas.json**. Notons que le chemin vers ce fichier JSON est un simple choix, il doit √™tre configurable.
- **√©criture de ressources** : lors d'une op√©ration d'√©criture pour cr√©er une nouvelle ressource, ou pour mettre √† jour une ressource existante, voici les √©tapes :
  - cr√©ation d'une liste de toutes les pizzas dans un array : cela correspond √† l'utilisation de la fonction **`parse`** pour tenter de charger ce qui est contenu dans la mini DB de pizzas.
  - mise √† jour de l'array soit en ajoutant un nouvel objet (une pizza), soit en modifiant un objet existant, soit en supprimant un objet.
  - r√©√©criture compl√®te du fichier JSON contenant la liste de pizzas sur base de l'array de pizzas qui a pr√©c√©demment √©t√© mis √† jour via la m√©thode **`serialize`**.

  Voici le code du router mis √† jour afin de g√©rer la persistance selon la strat√©gie d√©finie ci-dessus, les modifications √©tant surlign√©es :

```js numbered {2,5,45,47,51,58,60,64,76-78,87,89,98,100,104,107,123,125,129,131,133}
var express = require('express');
const { serialize, parse } = require('../utils/json');
var router = express.Router();

const jsonDbPath = __dirname + '/../data/pizzas.json';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

/* Read all the pizzas from the menu
   GET /pizzas?order=title¬†:¬†ascending order¬†by¬†title
¬†  GET /pizzas?order=-title¬†:¬†descending order¬†by¬†title
*/
router.get('/', (req, res, next) => {
  const orderByTitle =
    req?.query?.order?.includes('title') ? req.query.order : undefined;
  let orderedMenu;
  console.log(`order by ${orderByTitle ?? 'not requested'}`);

  const pizzas = parse(jsonDbPath, MENU);
  
  if (orderByTitle) orderedMenu = [...pizzas].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  console.log('GET /pizzas');
  return res.json(orderedMenu ?? pizzas);
});

// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  console.log(`GET /pizzas/${req.params.id}`);

  const pizzas = parse(jsonDbPath, MENU);

  const indexOfPizzaFound = pizzas.findIndex(pizza => pizza.id == req.params.id);

  if (indexOfPizzaFound < 0) return res.sendStatus(404);

  return res.json(pizzas[indexOfPizzaFound]);
});

// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const pizzas = parse(jsonDbPath, MENU);
  const lastItemIndex = pizzas?.length !== 0 ? pizzas.length - 1 : undefined;
  const lastId = lastItemIndex ? pizzas[lastItemIndex]?.id : undefined;
  const nextId = lastItemIndex !== 0 ? lastId + 1 : 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  pizzas.push(newPizza);

  serialize(jsonDbPath, pizzas);

  return res.json(newPizza);
});

// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  console.log(`DELETE /pizzas/${req.params.id}`);

  const pizzas = parse(jsonDbPath, MENU);

  const foundIndex = pizzas.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const itemsRemovedFromMenu = pizzas.splice(foundIndex, 1);
  const itemRemoved = itemsRemovedFromMenu[0];

  serialize(jsonDbPath, pizzas);

  return res.json(itemRemoved);
});

// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  console.log(`PATCH /pizzas/${req.params.id}`);

  const title = req?.body?.title;
  const content = req?.body?.content;

  console.log('POST /pizzas');

  if ((!title && !content) || title?.length === 0 || content?.length === 0) return res.sendStatus(400);

  const pizzas = parse(jsonDbPath, MENU);

  const foundIndex = pizzas.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const updatedPizza = {...pizzas[foundIndex], ...req.body};

  pizzas[foundIndex] = updatedPizza;

  serialize(jsonDbPath, pizzas);

  return res.json(updatedPizza);
});

module.exports = router;
```

Veuillez mettre √† jour votre fichier **/router/pizzas.js** sur base du code donn√© et testez le bon fonctionnement de l'application. Faites quelques requ√™tes pour ajouter et modifier des donn√©es et v√©rifiez, une fois que vous red√©marrer votre application, que les donn√©es persistent.

#### a.4.1.2) Application c√¥t√© client

Au niveau d'une IHM, il doit aussi √™tre possible de sauvegarder des informations.  
Or, pour des raisons de s√©curit√©, le browser ne peut pas cr√©er des fichiers JSON de mani√®re transparente √† l'utilisateur.  
Afin de sauvegarder des donn√©es, le browser met n√©anmoins √† disposition un web storage dans lequel on peut sauvegarder des donn√©es sous forme de cl√© / valeur, au format texte.  
Nous verrons cela plus tard en d√©tails.

Voici d√©j√† malgr√© tout un exemple de code, une fonction, permettant de sauvegarder les donn√©es de session d'un utilisateur dans le web storage d'un browser :

```js
const setUserSessionData = (user) => {
  const storageValue = JSON.stringify(user);
  localStorage.setItem(STORE_NAME, storageValue);
};
```

### a.4.2) Parsing de donn√©es JSON vers un objet JS

#### a.4.2.1) Application c√¥t√© serveur

La fonction JS **`JSON.parse(objectSerialized) `** permet de cr√©er un objet JS √† partir d'une **string** contenant des donn√©es au format JSON.

C√¥t√© serveur, il est ensuite facile de sauvegarder les donn√©es JSON au sein d'un fichier.

Voici un exemple de code, une fonction, permettant √† une application Express de cr√©er un objet JS sur base de donn√©es JSON se trouvant dans un fichier **.json** dont le chemin et nom complet sont indiqu√©s dans le param√®tre **filePath** :

```js
/**
 * Parse items given in a .json file
 * @param {String} filePath - path to the .json file
 * If the file does not exist or it's content cannot be parsed as JSON data,
 * use the default data.
 * @param {Array} defaultArray - Content to be used when the .json file does not exists
 * @returns {Array} : the array that was parsed from the file (or defaultData)
 */
function parse(filePath, defaultArray = []) {
  if (!fs.existsSync(filePath)) return defaultArray;
  const fileData = fs.readFileSync(filePath);
  try {
    // parse() Throws a SyntaxError exception if the string to parse is not valid JSON.
    return JSON.parse(fileData);
  } catch (err) {
    return defaultArray;
  }
}
```

Imaginez que, au sein du router traitant des ressources de type "pizzas", que l'on r√©cup√®re le menu des pizzas √† l'aide du fichier JSON dont le chemin et nom complet est donn√© dans **jsonDbPath**. Voici ce que donnerait l'op√©ration de lecture de toutes les pizzas :

```js
// Read all the pizzas from the menu
router.get('/', function (req, res) {
  console.log('GET /pizzas');
  const pizzas = parse(jsonDbPath, DEFAULT_MENU);
  res.json(pizzas);
});
```

#### a.4.2.2) Application c√¥t√© client

Au niveau d'une IHM, il doit aussi √™tre possible de r√©cup√©rer des donn√©es JSON qui auraient √©t√© sauvegard√©es au sein du web browser.

Nous verrons cela plus tard en d√©tails. Voici d√©j√† malgr√© tout un exemple de code, une fonction, permettant de parser les donn√©es de session d'un utilisateur se trouvant dans le web storage d'un browser :

```js
const getUserSessionData = () => {
  const retrievedUser = localStorage.getItem(STORE_NAME);
  if (!retrievedUser) return;
  return JSON.parse(retrievedUser);
};
```

# <a id="b"></a> b) Am√©lioration des outils de d√©veloppement

## <a id="b1"></a> b.1) Introduction

Dans le d√©veloppement de nos API, nous souhaitons plus de facilit√©s.  
Notamment, √† chaque changement de notre code, nous ne souhaitons pas devoir red√©marrer manuellement notre application.

Nous souhaiterions aussi b√©n√©ficier d'un debugger et d'autres outils, comme un linter...

## <a id="b2"></a> b.2) Red√©marrage automatique au changement d'un fichier

### b.2.1) Configuration de l'utilisation de nodemon

Il est possible de faire en sorte qu'√† chaque fois que vous sauvez un fichier, votre application **node.js** red√©marre automatiquement.

Voici la pr√©c√©dure :

- Installez **nodemon** au niveau du r√©pertoire du projet :

```bash
npm i nodemon -D
```

- Pour lancer **nodemon** (au lieu du simple **node**) quand on tape **`npm run dev`** : Veuillez ajouter la ligne **`"dev": "nodemon /bin/www"`** dans **package.json** :

```json {2}
"scripts": {
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www"
  },
```

### b.2.2) Configuration des fichiers √† ignorer pour √©viter des r√©d√©marrages

Il est possible d'indiquer les fichiers qui doivent √™tre ignor√©s par **nodemon** via l'ajout dans **package.json** :

```json
"nodemonConfig": {
    "ignore": [
      "data/*"
    ]
  },
```

Dans la configuration ajout√©e ci-dessous, tous les fichiers qui seraient mis √† jour dans le r√©pertoire **/data** ne provoqueront pas de red√©marrage du serveur **nodemon** lorsqu'il est lanc√© (en mode 'dev').

Veuillez installer **nodemon** dans le cadre de votre tutoriel **api-persistence** et configurer celui-ci pour que l'application ne red√©marre pas √† chaque fois que vous cr√©ez une nouvelle pizza.   
N'h√©sitez pas √† tester la cr√©ation d'une pizza avant de dire √† **nodemon** d'ignorer les fichiers se trouvant dans **/data**.

## <a id="b3"></a> b.3) Debugging

### b.3.1) Introduction

Est-ce que nous pouvons utiliser VS Code pour d√©bugger notre API ?  
Oui, heureusement, car le debugger est probablement le meilleur ami des d√©veloppeurs.

Il est toujours l√† pour aider, √† l'√©coute de nos investigations, mettant r√©guli√®rement en lumi√®re des pistes de sortie de probl√®mes, tout cela de mani√®re bienveillante, sans jamais nous brusquer üòÅ.

[Debugging via VS Code](https://code.visualstudio.com/docs/editor/debugging) [[R.59]](/references/#r59) fournit le d√©tails de comment d√©bugger sous VS Code. Nous vous offrons par la suite une fa√ßon pratique de rapidement d√©bugger.

### b.3.2) Debugging sans configuration

Sans aucune configuration, il est possible de d√©bugger une application **Node.js**.

Il suffit d'ouvrir le script d'entr√©e de votre application dans VS Code. Pour une application Express, le script d'entr√©e est **/bin/www**. Cliquez dans l'Explorer de VS Code sur **/bin/www** de votre tutoriel **api-persistence**. Une fois le script **/bin/www** ouvert, il ne reste plus qu'√† ex√©cuter le **Debug**.  
Pour ce faire :
- soit vous cliquez sur l'ic√¥ne "Run and Debug" √† gauche de l'Explorer, puis sur le bouton "Run and Debug";
- soit vous cliquez sur "Run" puis sur "Start Debugging";
- soit vous cliquez sur "F5",
- Il est probable que la premi√®re fois que vous lancez le **Debug**, vous devrez s√©lectionner **Node.js**   (il sera indiqu√© : "Select debugger") comme debugger dans une liste.

En r√©sum√©, une fois le debugger lanc√©, il suffit d'ajouter des breakpoints dans le code source et d'ex√©cuter le code pas √† pas.

N'h√©sitez pas √† ex√©cuter pas √† pas une op√©ration de votre api, comme la cr√©ation d'une pizza par exemple.

### b.3.3) Debugging avec une bonne configuration

Trouver une configuration qui permet de bien d√©bugger n'est pas si ais√©. Nous allons donc voir ensemble comment mettre en place une configuration des plus utiles dans le cadre de ce cours.

Premi√®rement, il est important que quand on lance le debugger, on puisse b√©n√©ficier de **nodemon** et des red√©marrages automatiques en cas de changement de code.  
Pour ce faire, veuillez mettre √† jour le fichier **packages.json** pour rajouter un script de d√©marrage :

```json {2}
"scripts":¬†{
¬†¬†¬†¬†"debug":¬†"nodemon¬†./bin/www",
¬†¬†¬†¬†"dev":¬†"nodemon¬†./bin/www",
¬†¬†¬†¬†"start":¬†"node¬†./bin/www"
¬†¬†},
```

Nous allons maintenant cr√©er une configuration de debugging associ√©e √† notre repo **web2** :

- Cliquez sur l'ic√¥ne "Run and Debug" √† gauche de l'Explorer, puis sur le lien "create launch.json file" (.vscode/launch.json).
- Quand il sera indiqu√© "Select debugger", s√©lectionnez **Node.js**.  
  NB : Peu importe le debugger que vous s√©lectionnez, car vous aller par la suite copier / coller la configuration propos√©e.
- Une fois le debugger **Node.js** choisi, VS Code cr√©e un r√©pertoire **.vscode** √† la racine du folder ouvert au sein de VS Code (normalement vous devriez avoir ouvert votre repo local **web2**) contenant un fichier **launch.json** et une configuration initiale. Veuillez remplacer le contenu de ce fichier par celui-ci :

```json {10-14,19}
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Launch via NPM",
      "request": "launch",
      "runtimeArgs": ["run-script", "debug"],
      "runtimeExecutable": "npm",
      "skipFiles": ["<node_internals>/**"],
      "type": "pwa-node",
      "cwd": "${fileDirname}"
    }
  ]
}
```

**runtimeArgs** permet de s√©lectionner le script √† lancer par le debugger, √† savoir ici : **debug**.  
Ainsi, quand on lancera le debugger, celui-ci lancera le programme avec l'√©quivalent de la commande **`npm run debug`**.

**`"cwd":"${fileDirname}"`** : **cwd** permet d'indiquer le chemin vers la racine du programme √† d√©bugger. La variable **fileDirname** permet de s√©lectionner le programme √† d√©bugger sur base du fichier ouvert et actif dans VS Code.

Si vous avez plusieurs applications au sein d'un folder de VS Code, pour d√©bugger une application en particulier, nous vous conseillons cette approche :
- Ouvrez le fichier **package.json** de l'application √† d√©bugger ;
- Cliquez sur l'ic√¥ne **Run and Debug** √† gauche de l'Explorer, puis cliquez sur **Start Debugging** (ou cliquez juste sur **F5**) en v√©rifiant que la configuration de debugging s√©lectionn√©e est bien nomm√©e **Launch via NPM**.

Nottons que le nom de la configuration de debugging peut facilement √™tre modifi√©e en changeant la valeur de l'attribut **name** dans **/.vscode/launch.json**.

Veuillez tester cette configuration de debugging au sein de votre repo local **web2**.  
Vous pourriez par exemple observer pas √† pas une op√©ration de suppression d'une pizza, afin de voir √† quel moment le contenu de l'array **pizzas** est mis √† jour, ainsi que le fichier **/data/pizzas.json**.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**api-persistence**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
[api-persistence](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/persistence).

## <a id="b4"></a> b.4) Autres outils de d√©veloppement

Il serait utile de b√©n√©ficier :

- d'un linter : celui-ci devrait imposer un "style guide" qui est √©quivalent √† notre style de programmation pour les IHM.
- d'un formater : celui-ci devrait automatiquement permettre d'am√©liorer le style de notre code pour se rapprocher de ce qui est impos√© par le linter.

Un boilerplate a √©t√© cr√©√© afin de mettre en place ces outils :
[basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate)

Vous ne devez pas savoir comment cr√©er et configurer un tel boilerplate.  
N√©anmoins, pour les personnes tr√®s curieuses, la cr√©ation du boilerplate est expliqu√©e dans le **README** du boilerplate.

Pour la suite du cours, nous n'utiliserons plus le g√©n√©rateur d'application Express, mais ce boilerplate.

Il est important d'avoir install√© **ESLint** et **prettier** au sein de VS Code pour bien utiliser le boilerplate d'une API.  
Vous l'avez normalement d√©j√† fait au module 2. Si non, veuillez suivre la proc√©dure donn√©e ici : [Module 2 : a.6) Installation des extensions pour le linter et le formater](/modules/2/#a6)

# <a id="c"></a> c) Exercice 5.1 : Persistance de la RESTfull API pour myMovies

Vous allez faire un refactor de la RESTful API de **myMovies**, afin d'utiliser les outils de d√©veloppement modernes mis √† disposition dans un boilerplate et afin de rendre les donn√©es persistantes dans un fichier JSON.

Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :

- Veuillez cr√©er un nouveau projet dans votre repository local et votre web repository (normalement appel√© **web2**) nomm√© **/exercises/module5/5.1** sur base du boilerplate : [basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate).
- Reprenez le code du router que vous avez d√©velopp√© √† l'exercice pr√©c√©dent (Exercice 4.1) et int√©grez le dans votre nouveau projet.
- Faites un refactor de votre API g√©rant les films afin que les ressources persistent au sein du fichier **/data/films.json** ou **/data/movies.json**.
- Veuillez tester toutes les fonctions de la RESTful API pour la collection de films √† l'aide du REST Client en copiant les requ√™tes d√©velopp√©es pour l'Exercice 4.1 (fichier **films.http** du r√©pertoire **REST Client**). Normalement, il n'y a pas de nouvelles requ√™tes √† √©crire, il suffit juste de les ex√©cuter.

Le code de votre application web doit donc se trouver dans votre repository local et votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√© **/exercises/module5/5.1**.

Veuillez faire un **commit** de votre code avec le message suivant : "**myMovies : module 5 : persistent API**".

# <a id="d"></a> d) Refactoring √† l'aide d'un "fat model"

## <a id="d1"></a> d.1) Architectures possibles ?

Si nous reprenons le code actuel du tutoriel de l'API g√©rant des pizzas ([api-persistence](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/persistence)), nous pouvons d√©tecter que celui-ci pourrait √™tre plus propre.

Par exemple, le routeur de "pizzas" s'occupe tant de g√©rer les requ√™tes des clients que d'acc√©der directement aux donn√©es.  
G√©n√©ralement, nous pr√©f√©rons s√©parer le code g√©rant les acc√®s aux donn√©es du code g√©rant la pr√©sentation du r√©sultat des op√©rations.

On peut donc se demander comment s√©parer le code traitant de sujets diff√©rents, o√π ayant des responsabilit√©s fort diff√©rentes. Il existe une multitude d'architectures possibles, voici par exemple certains des plus grands noms :
- **Architecture MVC (Model View Controller)** ; au niveau backend, ce genre d'architecture est g√©n√©ralement tr√®s utile quand on fait des MPA (ou Multi-Page Applications) via du Server-Side Rendering. Les **Views** permettent de g√©n√©rer le frontend √† l'aide d'un moteur de templating ; le **Controller** s'occupe de traiter les requ√™tes en appelant le **Model** pour l'acc√®s aux op√©rations sur les donn√©es et en renvoyant les **Views** ad√©quates. Pour une API, cette architecture n'est pas la plus adapt√©e.
- **Architecture classique "three-tiers"** ; au nivau backend, quand on d√©veloppe une architecture trois tiers, cela signifie que l'on d√©coupe notre API en trois couches :
  - **couche de pr√©sentation** : cette couche est responsable de pr√©senter les ressources aux clients et d'interpr√©ter les repr√©sentations des ressources donn√©es dans les requ√™tes ;
  - **couche business** : cette couche s'occupe de toute la logique de l'API, elle fait l'interm√©diaire entre la couche de pr√©sentation et la couche de donn√©es ;
  - **couche de donn√©es** : cette couche s'occupe des acc√®s aux donn√©es et permet notamment la persistance des ressources au sein de bases de donn√©es.  
  Le mod√®le trois tiers est fort int√©ressant, mais il demande un peu trop d'√©criture de codes sans grande valeur ajout√©e quand nous utilisons le framework Express.
- ...

Finalement, parmi les architectures classiques, il n'y a pas r√©ellement une architecture qui colle parfaitement √† ce qui est offert par le framework Express, sans devoir √©crire du code sans valeur ajout√©e.  
Ainsi, nous allons simplement cr√©er notre propre architecture "maison", sur base de ces points :
- On souhaite pouvoir facilement remplacer la couche d'acc√®s aux donn√©es sans changer la repr√©sentation des ressources ; en effet, dans un premier temps, nous sauvegarderons des donn√©es dans des fichiers JSON. Plus tard, si l'on venait √† sauvegarder les donn√©es dans un syst√®me de gestion de base de donn√©es, on ne veut pas devoir mettre √† jour le code prenant en compte les requ√™tes des clients et pr√©sentant la r√©ponse √† ces requ√™tes ; en gros, on souhaite que le code de nos routers, au sein d'Express, soit ind√©pendant de l'impl√©mentation des acc√®s aux donn√©es.
- Nous n'avons pas vraiment de contraintes pour l'aspect "business" de nos APIs : la logique de l'application peut soit s'associer √† la couche de donn√©es, soit √† la couche pr√©sentation. N√©anmoins, nous allons pr√©f√©rez associer un maximum de la logique de notre application √† ce que nous allons appeler un **fat model**. Le **fat model** contiendra toutes les op√©rations possibles sur les ressources, ainsi que les acc√®s aux donn√©es.
- Le **fat model** peut √™tre soit √©crit en orient√© objet, soit simplement √™tre un module fournissant des fonctions. Dans le cadre de ce cours, nous choisissons de pr√©senter un maximum de programmation fonctionnelle plut√¥t que de l'orient√© objet.  
  N√©anmoins, n'h√©sitez pas √† √©crire des classes si cela vous tient √† coeur üòâ.

## <a id="d1"></a> d.2) Architecture Express & "fat model"

Voici l'architecture que nous allons appliquer dans nos prochaines API :

<ScrollableImage name="architecture.png" minWidth="859px" maxWidth="859px" />
<figcaption>Architecture recommand√©e pour ce cours</figcaption>

Voici quelques explications sur ce diagramme que nous allons appliquer dans le prochain tutoriel :

1. Un client fait la requ√™te √† l'API demandant de lire toutes les pizzas.
2. Le router de "pizzas" prend le r√¥le de "Controller". Il s'occupe de traiter de la requ√™te et d'appeler une op√©ration du **fat model** pour acc√©der aux ressources.
3. Le **fat model** s'occupe d'acc√©der aux donn√©es, qui se trouvent au sein d'un fichier JSON, et de les lire.
4. Le **fat model** retourne un objet JS des donn√©es au router de "pizzas".
5. Le router de "pizzas" renvoient une repr√©sentation JSON de l'objet JS, un array de pizzas, au client.

Nous allons maintenant faire un refactor de notre API de gestion des pizzas en cr√©ant et utilisant un "fat model".

Au sein de votre repo **web2**, √† l'aide du boilerplate du cours [basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate), veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/api/fat-model**.

Si vous ne voyez pas comment utiliser le boilerplate, tout est expliqu√© dans le **README** associ√© au repository.  
N'h√©sitez pas √† le lire ; )

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/api/fat-model**.

Nous allons commencer par cr√©er le **fat model** offrant les op√©rations sur les pizzas.   
Veuillez cr√©er le fichier **/models/pizzas.js**.  
Au sein de ce fichier, veuillez ajouter le code s'occupant des op√©rations sur les ressources de type "pizzas" :

```js
const path = require('node:path');
const { parse, serialize } = require('../utils/json');

const jsonDbPath = path.join(__dirname, '/../data/pizzas.json');

const defaultPizzas = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

function readAllPizzas(orderBy) {
  const orderByTitle = orderBy?.includes('title') ? orderBy : undefined;
  let orderedMenu;
  const pizzas = parse(jsonDbPath, defaultPizzas);
  if (orderByTitle)
    orderedMenu = [...pizzas].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  const allPizzasPotentiallyOrderd = orderedMenu ?? pizzas;
  return allPizzasPotentiallyOrderd;
}

function readOnePizza(id) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const indexOfPizzaFound = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (indexOfPizzaFound < 0) return undefined;

  return pizzas[indexOfPizzaFound];
}

function createOnePizza(title, content) {
  const pizzas = parse(jsonDbPath, defaultPizzas);

  const createdPizza = {
    id: getNextId(),
    title,
    content,
  };

  pizzas.push(createdPizza);

  serialize(jsonDbPath, pizzas);

  return createdPizza;
}

function getNextId() {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const lastItemIndex = pizzas?.length !== 0 ? pizzas.length - 1 : undefined;
  if (lastItemIndex === undefined) return 1;
  const lastId = pizzas[lastItemIndex]?.id;
  const nextId = lastId + 1;
  return nextId;
}

function deleteOnePizza(id) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const foundIndex = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (foundIndex < 0) return undefined;
  const deletedPizzas = pizzas.splice(foundIndex, 1);
  const deletedPizza = deletedPizzas[0];
  serialize(jsonDbPath, pizzas);

  return deletedPizza;
}

function updateOnePizza(id, propertiesToUpdate) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const foundIndex = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (foundIndex < 0) return undefined;

  const updatedPizza = { ...pizzas[foundIndex], ...propertiesToUpdate };

  pizzas[foundIndex] = updatedPizza;

  serialize(jsonDbPath, pizzas);

  return updatedPizza;
}

module.exports = {
  readAllPizzas,
  readOnePizza,
  createOnePizza,
  deleteOnePizza,
  updateOnePizza,
};
```

Maintenant, il ne reste plus qu'√† mettre √† jour le router **/routes/pizzas.js** afin de faire les appels aux fonctions offertes par le mod√®le :

```js
const express = require('express');
const {
  readAllPizzas,
  readOnePizza,
  createOnePizza,
  deleteOnePizza,
  updateOnePizza,
} = require('../models/pizzas');

const router = express.Router();

/* Read all the pizzas from the menu
   GET /pizzas?order=title : ascending order by title
   GET /pizzas?order=-title : descending order by title
*/
router.get('/', (req, res) => {
  const allPizzasPotentiallyOrdered = readAllPizzas(req?.query?.order);

  return res.json(allPizzasPotentiallyOrdered);
});

// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  const foundPizza = readOnePizza(req.params.id);

  if (!foundPizza) return res.sendStatus(404);

  return res.json(foundPizza);
});

// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content =
    req?.body?.content?.length !== 0 ? req.body.content : undefined;

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const createdPizza = createOnePizza(title, content);

  return res.json(createdPizza);
});

// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  const deletedPizza = deleteOnePizza(req.params.id);

  if (!deletedPizza) return res.sendStatus(404);

  return res.json(deletedPizza);
});

// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  const title = req?.body?.title;
  const content = req?.body?.content;

  if ((!title && !content) || title?.length === 0 || content?.length === 0) {
    return res.sendStatus(400);
  }

  const updatedPizza = updateOnePizza(req.params.id, { title, content });

  if (!updatedPizza) return res.sendStatus(404);

  return res.json(updatedPizza);
});

module.exports = router;
```

Lancer votre API soit via le debugger, soit via la commande **`npm run dev`**.  
Veuillez ensuite tester que tout fonctionne bien en ex√©cutant les requ√™tes HTTP d√©j√† pr√©sentes dans le r√©pertoire **REST Client** du boilerplate.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**fat-model**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
[fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

# <a id="e"></a> e) Exercice 5.2 : Refactoring de la RESTfull API pour myMovies

Vous allez faire un nouveau refactor de la RESTful API de **myMovies**, afin de restructurer l'architecture de l'application selon l'architecture recommand√©e, en utilisant un "fat model" pour g√©rer les op√©rations sur les films.

Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :

- Veuillez cr√©er un nouveau projet dans votre repository local et votre web repository (normalement appel√© **web2**) nomm√© **/exercises/module5/5.2** sur base d'une copie de votre Exercice 5.1 ou sur base du boilerplate : [basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate).
- Faites un refactor de votre API g√©rant les films afin que tout ce qui traite des op√©rations sur les ressources soit fait au sein du mod√®le **/models/films.json** ou **/models/movies.json**.
- Veuillez tester toutes les fonctions de la RESTful API pour la collection de films √† l'aide du REST Client en copiant les requ√™tes d√©velopp√©es pour l'Exercice 4.1 (fichier **films.http** du r√©pertoire **REST Client**). Normalement, il n'y a pas de nouvelles requ√™tes √† √©crire, il suffit juste de les ex√©cuter.

Le code de votre application web doit donc se trouver dans votre repository local et votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√© **/exercises/module5/5.2**.

Veuillez faire un **commit** de votre code avec le message suivant : "**myMovies : module 5 : API with fat-model**".
