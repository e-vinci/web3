---
title: 'Module 5 : React Context'
description: "React Context"
---

# Module 5 : React Context
Ce module vous offre principalement la gestion d'un √©tat global pouvant √™tre consomm√© l√† o√π n√©cessaire gr√¢ce √† React Context.

Voici les sujets trait√©s :
- a) [React Context](#a)
  - a.1) [Introduction au React Context](#a1)
  - a.2) [Fonctionnement de React Context](#a2)
  - a.3) [Exemple de React Context](#a3)
  - a.4) [State management & Redux](#a4)
- b) [Exercice 5.1 : Votes pr√©d√©finis](#b)
- c) [Exercice 5.2 : Votes d'opinions](#c)
- d) [R√©sum√©](#d)
- e) [üç¨ Exercice 5.3 : pour s'entra√Æner encore](#e)


# <a id="a"></a>a) React Context

## <a id="a1"></a> a.1) Introduction au React Context
La librairie **React Context** a pour objectifs de r√©gler un probl√®me que vous avez probablement d√©j√† ressenti durant les exercices pr√©c√©dent et qui s'appelle le "**prop drilling**" : afin de permettre √† un composant qui se trouve bas dans l'arbre de composants de pouvoir acc√©der aux fonctions et au valeurs d√©finies plus haut, il faut passer ces fonctions et ces valeurs √† tous les composants interm√©diaires, m√™me si ceux-ci n'en ont pas besoin.  
On doit "forer" √† travers les composants interm√©diaires pour atteindre le composant de bas niveau, ce qui a donn√© son nom au **prop drilling**.


Illustration : La fonction **toggle(id)** est d√©finie dans le composant **Todos** et est ensuite pass√©e √† chaque composant interm√©diaire afin d'atteindre le sous-sous-sous composant **ToggleTodo** :

<ScrollableImage name="propDrilling.png" minWidth="600px" maxWidth="1128px" />
<figcaption>How to avoid Prop-drilling in Angular [R.7]</figcaption>


Le **props drilling** a plusieurs d√©savantages : 
- il rend les changements plus p√©nibles (par exemple renommer une prop n√©cessite de mettre √† jour plus de fichiers que n√©cessaire) ;
- il cr√©e du bruit : des lignes de codes inint√©ressantes qui cachent les lignes √† plus haute valeur ;
- il m√©lange sans distinction toutes les props sans indication de celles qui sont li√©es entre elles.


Les contextes offrent une solution √† ces 3 probl√®mes en permettant √† un composant de bas niveau (le consumer) d'acc√©der directement √† un state qui est stock√© en dehors de l'arbre des composants (le context).
Il y a simplement un composant (le provider) qui est responsable de le g√©rer.


## <a id="a2"></a> a.2) Fonctionnement de React Context
Afin d'utiliser un contexte nous allons avoir besoin de 3 morceaux li√©s les uns aux autres : 

- le **contexte** en lui-m√™me, fabriqu√© par React gr√¢ce √† l'appel : `React.createContext()`
- un **ProviderWrapper** : un composant tr√®s similaire au composant **App** (ou **Boot**, ou **AppLoader**) qui contient tout le state : sa fonction est d'encapsuler le **Provider** brut et d√©finir un state gr√¢ce √† **useState** ainsi que des fonctions qui permettent de manipuler ce state.
La valeur de son **return** sera le **provider** brut √† qui il aura pass√© dans la prop "**value**" les diff√©rentes valeurs et fonction que nous souhaitons exposer.
- des **consumers** : diff√©rents composants qui feront usage du hook **useContext**. L'usage de ce hook donnera acc√®s aux valeurs expos√©es par le **ProviderWrapper** le plus proche (en remontant l'arbre des composants). Si aucun n'est trouv√©, le hook retournera "**null**".

NB : optionnellement, il est possible d'utiliser des hooks customs qui encapsulent un usage limit√© du **useContext**.

## <a id="a3"></a> a.3) Exemple de React Context
Imaginons que notre site web soit accessible en deux langues : fran√ßais et anglais.  
La langue est stock√©e dans un state assez haut dans l'arbre. Mais n'importe quel bouton doit savoir s'il doit afficher son texte en anglais ou en fran√ßais.  
En plus de cela, il existe un select dans la barre de navigation qui permet de changer la langue. 

Sans les contextes, nous devrions probablement passer une prop "**language**" dans absolument tous nos composants, m√™me ceux qui n'affichent pas de texte, parce qu'ils auraient sans doute un sous-composant qui en affiche, lui.  
Nous devrions aussi passer une prop "**setLanguage**" √† la barre de navigation et √† chacun de ses sous composants jusqu'√† arriver au morceau qui s'occupe effectivement de changer la **locale**.

A la place nous allons r√©aliser ces 4 √©tapes. 
### a.3.1) Etape 1 : Cr√©er un fichier contexte  
Ce n'est pas un composant classique, nous allons donc le placer dans **/src/contexts/LanguageContext.jsx** et pas dans **/src/components/**.

``` js
import React from "react";

const Context = React.createContext(null)

export default Context;
```

La valeur "**null**" est la valeur que nous r√©cup√©rerons plus tard si nous oublions de placer un **ProviderWrapper** autour du composant qui essaye d'exploiter le contexte.
Plut√¥t que de placer une valeur par d√©faut, nous utilisons **null** pour avoir une erreur claire que quelque chose ne va pas.

### a.3.2) Etape 2 : D√©finir le state et ses fonctions de manipulation du state
Jusqu'ici rien de trop compliqu√© mais nous devons maintenant d√©finir le state et les fonctions de manipulation de ce state que nous voulons exposer.
Pour ce faire, nous allons d√©finir un composant dont le return appellera le provider du contexte avec une prop "value" bien d√©finie dans **/src/contexts/LanguageContext.jsx** :

``` js
import React, { useState } from "react";

const Context = React.createContext(null)

    
const ProviderWrapper = (props) => {

    const [language, setLanguage] = useState("fr")
    const pickLanguage = (newLanguage) => {
        if (newLanguage !== "fr" && newLanguage !== "en")   throw "Invalid language selected : "+newLanguage;
        setLanguage(newLanguage)    
    }
    
    const exposedValue = {
        language,
        pickLanguage,
    }
    
    return <Context.Provider value={exposedValue}>
        { props.children }
    </Context.Provider>    
}
    
export {    
    Context,
    ProviderWrapper,    
}    
```

Un peu plus de code ici mais rien d'extraordinaire : 

- On d√©finit un component **ProviderWraper** qui utilise un **useState**
- Le composant d√©finit une m√©thode **pickLanguage** qui fait une simple v√©rification en plus du **setLanguage**.
- Pour plus de clart√©, on pr√©pare un seul objet qui regroupe l'ensemble de ce qu'on s'appr√™te √† exposer aux consumers du contexte : **exposedValue**
- Dans le return, on renvoie le **Provider** brut, celui du contexte. Sa prop "**value**" est l'objet qu'on a pr√©par√©.
- On ajoute un export nomm√© qui permet d'acc√©der au **ProviderWrapper** et au **contexte** lui-m√™me.

Vous pouvez remarquer aussi qu'on utilise une prop sp√©ciale : **props.children**, celle-ci prendra tout son sens √† l'√©tape suivante.

### a.3.3) Etape 3 : Broadcaster le contexte √† l'aide du Provider
On peut maintenant placer le **ProviderWrapper** quelque part dans l'arbre des composants. On va typiquement faire ceci dans un composant qu'on placera au dessus de **App**, par exemple **AppLoader**, ou **Boot**.  
Dans le fichier **/src/components/App/AppLoader.jsx** :

``` js
import { ProviderWrapper as LanguageProviderWrapper } from "contexts/LanguageContext.jsx";
import App from "components/App/App.jsx";

const AppLoader= () => {
  return (
    <LanguageProviderWrapper >
        <App...>
 
      </LanguageProviderWrapper >
  )
}
```

On appelle ici le **LanguageProviderWrapper** mais on ne lui passe aucune prop.  
Par contre, pour la premi√®re fois, on utilise une balise ouvrante s√©par√©e de la balise fermante.
Lorsqu'on fait cela, tout ce qu'on place entre les balises ouvrantes et fermantes sera pass√© au composant sous la forme d'un tableau qui s'appelle **props.children**.  
Le composant qui re√ßoit cette prop (notre **ProviderWrapper**) peut donc d√©cider de ce qu'il fait de ce tableau. Dans notre cas on l'affiche simplement, mais on pourrait l'afficher conditionnellement, ou n'en afficher qu'une partie par exemple.

Attention, √† cette √©tape-ci, vous devez vous assurer que le point d'entr√©e de votre programme, `index.js`, fait bien appel √† **AppLoader** et plus √† **App**. Votre `index.js` ressemblera √† cela :
``` js
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<AppLoader />);
```

### a.3.4) Etape 4 : Consommer le contexte dans un composant
On peut maintenant utiliser le hook **useContext** dans n'importe quel composant sous l'**AppLoader**, par exemple dans un fichier **/src/components/FoobarButton** : 
``` js
import { Context as LanguageContext } from "contexts/LanguageContext";

const FoobarButton = () => {
   const { language, pickLanguage } = useContext(LanguageContext )
}
```

Si jamais un composant appelle **pickLanguage**, cela aura pour effet de :
1. mettre √† jour le state du **ProviderWrapper**, 
2. qui d√©clenchera un render de celui-ci , 
3. qui d√©clenchera √† son tour un render de **App** 
4. et de tous les composants plus bas dans l'arbre
5. qui, au travers de **useContext**, auront acc√®s √† une valeur √† jour.

### a.3.5) Plus de documentation
- Documentation g√©n√©rale de React sur les contextes : [Context](https://reactjs.org/docs/context.html) [[R.6]](/references/#r6)
- Documentation plus sp√©cifique sur le hook useContext : [useContext](https://reactjs.org/docs/hooks-reference.html#usecontext) [[R.6]](/references/#r6)
- Article assez complet et r√©cent sur l'int√©r√™t et l'usage des contextes : [How to Use React‚Äôs Context API and useContext() Hooks Effectively](https://medium.com/better-programming/how-to-use-reacts-context-api-and-usecontext-hooks-effectively-ed98ad9343b6) [[R.8]](/references/#r8)

## <a id="a4"></a> a.4) State management & Redux
Jusqu'ici nous vous avons pouss√© √† stocker le state de l'application dans un composant. Vous devrez dor√©navant choisir o√π stocker celui-ci : 
- dans un **component**  : si ce que vous avez √† stocker est propre au composant et fortement li√© √† l'affichage. Par exemple : l'√©tat visible ou cach√© d'une bulle d'information, l'option actuellement highlighted d'une liste, etc.
- dans un **contexte** : si ce que vous avez √† stocker est susceptible d'int√©resser plusieurs composants, voire l'application en entier. Par exemple : la langue de l'utilisateur, le r√©sultat d'un appel d'API...

Cette probl√©matique de choix, qu'on appelle le state management, n'est pas √©vidente et n'a pas de r√®gle stricte. Parfois plusieurs choix sont bons, parfois on doit changer d'avis. 

Dans la documentation en ligne vous trouverez souvent mention d'un autre choix : **Redux**.
C'est un outil assez lourd √† mettre en place qui force chaque mise √† jour du state √† passer par des √©tapes tr√®s stricte et qui force notamment :
1. la g√©n√©ration d'un message (**action**), souvent g√©r√©e par des fonctions sp√©cialis√©es (action creator) pour CHAQUE interaction (click, change, emission de requ√™te, reception de r√©ponse, ...), 
2. le processing des messages par des fonctions sp√©cialis√©es (les **reducers**) qui vont mettre √† jour le state.
3. l'√©criture d'autres fonctions sp√©cialis√©es pour interroger le state (**state selector**) car le fait que celui-ci est unique le rend rapidement tr√®s complexe.

Nous avons d√©cid√© de ne pas voir avec vous cet outil car sa lourdeur est un frein immense qui n'est que tr√®s rarement justifi√©.  
Les contextes permettent de faire le m√™me travail pour une fraction de l'effort dans une immense majorit√© des cas. 

React propose aussi une alternative √† Redux via le hook "useReducer", que nous ne verrons pas au cours mais vous pouvez vous documenter sur le sujet.

# <a id="b"></a>b) Exercice 5.1 : Votes pr√©d√©finis
Afin de vous convaincre que les contextes sont aussi puissants que Redux, nous nous sommes inspir√©s grandement des exercices de Fullstack open concernant Redux.

Imaginons un simple syst√®me de vote de satisfaction : l'application propose 3 boutons : 
- Good
- Ok
- Bad

Et nous souhaitons m√©moriser combien de fois chaque bouton a √©t√© cliqu√©.

Exemple de r√©sultat :

<ScrollableImage name="scores.png" minWidth="287px" maxWidth="287px" />

Plut√¥t que de stocker le state dans un composant comme nous l'aurions fait pr√©c√©demment, nous allons cr√©er un contexte **/src/contexts/countersContext** dont le **ProviderWrapper** stockera le state et exposera les fonctions **increaseGood**, **increaseOk**, **increaseBad**, ainsi que les valeurs associ√©es et une fonction **resetAll**.

L'**AppLoader** s'occupera de placer le **ProviderWrapper** dans son return, autour du composant **App**.
Le composant **App** affichera les 3 valeurs directement ainsi que 4 sous composants : **GoodButton**, **OkButton**, **BadButton**, et **ResetButton**.
Chacun d'entre eux devra aller chercher la fonction dont il a besoin dans le contexte en utilisant **useContext**.

Pour cet exercice, nous vous demandons explicitement de cr√©er les 4 composants **Button** cit√©s ci-dessus. Ne faites pas de composant abstrait recevant des props **text** et **onClick**, √©crivez des composants sp√©cialis√©s, m√™me si cela introduit de la duplication. Le but est d'illustrer le fonctionnement des contextes !

# <a id="c"></a>c) Exercice 5.2 : Votes d'opinions
Nous allons √©crire une nouvelle application qui va permettre de donner son opinion et voter.

Au lieu d'avoir 3 valeurs uniques parmi lesquelles choisir, comme √† l'exercice pr√©c√©dent, nous allons maintenant proposer que chacun donne son opinion ou vote pour une opinion existante. 

L'√©cran doit donc afficher une liste des opinions avec leur score actuel ainsi qu'un bouton vote.
Apr√®s la liste, un champ texte et un bouton **Add** permet d'ajouter une opinion (avec un score initial de 1).
Les opinions sont toujours tri√©es dans l'ordre d√©croissant des votes. Le contexte propose une propri√©t√© **sortedOpinions** pour ce faire.

Exemple de r√©sultat :
<ScrollableImage name="opinions.png" minWidth="363px" maxWidth="363px" />

# <a id="d"></a> d) R√©sum√©
- Nous utilisons le m√©canisme des contextes pour stocker un state qui doit √™tre largement acc√©d√©.
- Gr√¢ce √† ce m√©canisme, nous b√©n√©ficions des avantages des mises √† jour des props sans devoir faire de prop drilling.
- En plus du state en lui-m√™me, il est n√©cessaire d'exposer les fonction pour le modifier.
- Un composant sp√©cial, le **ProviderWrapper**, s'occupe de "broadcaster" son state au travers du contexte.


# <a id="e"></a> e) üç¨ Exercice 5.3 : pour s'entra√Æner encore
Cr√©er un contexte **themeContext**, celui-ci permet de **setDarkTheme()**, et **setLightTheme()**, **toggleTheme()**, ainsi que **getCurrentThemeDetails()**.
Lorsqu'on appelle **getCurrentThemeDetails()**, on recoit un objet avec les propri√©t√©s suivantes : 
- **backgroundColor**
- **primaryTextColor**
- **secondaryTextColor**
- **linkColor**

Placez dans le footer de votre application un bouton pour changer de th√®me et ajoutez dans tous les composant de votre application un **useContext** afin d'utiliser les couleurs du th√®me actuellement choisi.