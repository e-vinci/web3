---
title: "Module 7 : React router & UI library"
description: "React router & UI library"
---

# Module 7 : React router & Ant Design
Ce module vous offre principalement la gestion de React Router et l'utilisation d'Ant Design.

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web3course </PathViewerItem>
    <PathViewerItem to="/modules/7" selected> Module 7 </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Introduction au routing </InternalPageMenuItem>
  <InternalPageMenuItem> Navigation basique entre pages </InternalPageMenuItem>
  <InternalPageMenuItem> Mise en place de React Router </InternalPageMenuItem>
  <InternalPageMenuItem> Utilisation de useNavigation </InternalPageMenuItem>
  <InternalPageMenuItem> Nested routes </InternalPageMenuItem>
  <InternalPageMenuItem> URL dynamiques </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 7.1 : React Router de base </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer l'√©tat avec React Router ? </InternalPageMenuItem>
  <InternalPageMenuItem> Utilisation d'un OutletContext </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 7.2 : √âtat avec un router </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 7.3 : Routes dynamiques </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Introduction au routing </InternalPageTitle>

Lorsqu'on parle d'une IHM, nous souhaitons g√©n√©ralement afficher diff√©rents √©crans en r√©agissant aux actions des utilisateurs.

Le routage (ou routing en anglais) est ce qui rend possible l'affichage de diff√©rents √©crans.

Dans les applications "old school" de type **Multi-Page-Application** (**MPA**), pour changer de page, il faudrait :
- Faire un clic sur un √©l√©ment qui permet de faire une requ√™te HTTP au serveur pour demander un page.
- Le browser fait la requ√™te HTTP de type GET au serveur.
- L'application serveur (le backend) s'occupe du rendu de l'HTML et le renvoie au browser (le client).
- Le browser affiche cette page.

Dans les applications que nous d√©veloppons dans ce cours, l'architecture est compl√®tement diff√©rente. Nous d√©veloppons des **Single-Page-Applications** (**SPA**), pour changer de page :
- Il faut cliquer sur un √©l√©ment de la page permettant la navigation.
- Le JS ex√©cut√© dans le browser s'occupe de cr√©er l'illusion que l'on change de page en faisant lui-m√™me le rendu de la nouvelle page.
- Si des donn√©es sont n√©cessaires pour afficher la page, le JS ex√©cut√© dans le browser s'occupera de faire un "fetch" de celles-ci au format JSON (RESTful API) et g√©n√©rera dynamiquement l'HTML n√©cessaire.

Ainsi, dans une **SPA**, une seule page est charg√©e la toute premi√®re fois que l'on acc√®de au serveur : c'est `index.html` et tous les assets associ√©s (scripts JS, les images, CSS, sons...). Par la suite, on va utiliser un router (qui se trouvera dans un script JS) qui s'occupera de faire du "**Client Side Rendering**" (rendu c√¥t√© client de l'HTML).  

Dans nos applications `Vite + React`, c'est le code transpil√© du JSX vers le JS qui s'occupera :
- d'acc√©der √† un container pr√©sent dans la repr√©sentation m√©moire des √©l√©ments HTML de la page (par exemple la `div#root`).
- de mettre √† jour la repr√©sentation m√©moire de ce container avec les √©l√©ments HTML attendu pour la page demand√©.  

Ensuite, le browser n'aura plus qu'√† redessiner la page sur base de la nouvelle repr√©sentation m√©moire des √©l√©ments HTML de la page.

Notons que dans une MPA, on parle de "Server Side Rendering", car c'est le backend qui est responsable de la g√©n√©ration de l'HTML ; cela se fait souvent √† l'aide d'un moteur de templating pour g√©n√©rer des views (par exemple via `Handlebars` qui permet de g√©n√©rer des views dans une application `Node.js`).

# <InternalPageTitle> Navigation basique entre pages </InternalPageTitle>

A notre stade actuel de connaissances, nous pourrions tr√®s facilement organiser la navigation entre plusieurs page, simplement √† l'aide d'une variable d'√©tat et des gestionnaires de clics.

Pour ce tutoriel, nous allons partir d'une base de code minimaliste. Veuillez donc cr√©er un nouveau projet `Vite + React` nomm√© `routing`.  
Vous ne vous souvenez plus comment faire ? Voici la commande :

```bash
npm create vite@latest routing -- --template react
```

Veuillez remplacer le code de `App` :
```jsx
import { useState } from "react";

const HomePage = () => <div>Home Page</div>;
const AboutPage = () => <div>About Page</div>;
const ContactPage = () => <div>Contact Page</div>;

const App = () => {
  const [currentPage, setCurrentPage] = useState("Home");

  const navigateTo = (page) => {
    setCurrentPage(page);
  };

  const renderPage = () => {
    switch (currentPage) {
      case "Home":
        return <HomePage />;
      case "About":
        return <AboutPage />;
      case "Contact":
        return <ContactPage />;
      default:
        return <HomePage />;
    }
  };

  return (
    <div>
      <nav>
        <button onClick={() => navigateTo("Home")}>Home</button>
        <button onClick={() => navigateTo("About")}>About</button>
        <button onClick={() => navigateTo("Contact")}>Contact</button>
      </nav>
      {renderPage()}
    </div>
  );
};

export default App;
export { HomePage, AboutPage, ContactPage };
```

Nous avons donc ici d√©fini 3 composants React qui repr√©sentent 3 pages, et une fonction qui permet, lors d'un clic, d'afficher la page associ√©e au bouton.

Veuillez ex√©cuter l'application.

Tout fonctionne bien !

üí≠ Mais qu'est-ce qui nous manque ?

Voici ce qui fait d√©faut :
- Si nous faisons un refresh de la page, nous perdons la page en cours. Par exemple, si nous sommes sur `ContactPage`, nous serons redirig√© vers `HomePage`.
- Nous n'avons pas d'historique des pages visit√©es, nous ne pouvons pas revenir en arri√®re, ni en avant dans le temps.
- Nous n'avons pas une URL sp√©cifique pour chaque √©cran.

Nous allons donc mettre en place en routeur afin de b√©n√©ficier de ces fonctions manquantes.

# <InternalPageTitle> Mise en place de React Router </InternalPageTitle>

## Introduction
`React Router` est une librairie qui fournit une belle solution pour g√©rer la navigation dans une application React.

Sa documentation est disponible ici : https://reactrouter.com/en/main

## Installation de la librairie

Dans un premier temps, il faut donc installer la librairie : 
```sh
npm i react-router-dom
```

## Mise en place de routes basiques

Dans un premier temps, nous allons voir comment cr√©er la configuration la plus simple d'un router. Veuillez mettre √† jour `/src/main.jsx` :
```jsx numbered highlighting="5,7-20,24"
import React from "react";
import ReactDOM from "react-dom/client";
import { AboutPage, ContactPage, HomePage } from "./App.jsx";
import "./index.css";
import { RouterProvider, createBrowserRouter } from "react-router-dom";

const router = createBrowserRouter([
  {
    path: "/",
    element: <HomePage />,
  },
  {
    path: "/about",
    element: <AboutPage />,
  },
  {
    path: "/contact",
    element: <ContactPage />,
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router}/>  
  </React.StrictMode>
);
```

Ici, nous avons donc `createBrowserRouter` qui cr√©e une configuration pour nos 3 routes, et chaque route va afficher une page.

Ensuite, nous utilisons le `RouterProvider` pour fournir la configuration du routeur √† l'ensemble de l'application et pour permettre aux composants de l'application d'acc√©der au contexte du router.

Pour cette premi√®re utilisation du router, nous n'allons pas tenter d'optimiser la navigation. Nous allons donc int√©grer √† chaque page une `NavBar`.  
Chaque √©l√©ment de navigation va utiliser `<Link>` comme composant pour faire le lien avec les routes que nous avons configur√©es.

Veuillez mettre √† jour le composant `App` :
```jsx numbered highlighting="1,5-7"
import { Link } from "react-router-dom";

const NavBar = () => (
  <nav>
    <Link to="/">Home</Link>
    <Link to="/about">About</Link>
    <Link to="/contact">Contact</Link>
  </nav>
);

const HomePage = () => (
  <div>
    <NavBar />
    <p>Home Page</p>
  </div>
);
const AboutPage = () => (
  <div>
    <NavBar />
    <p>About Page</p>
  </div>
);
const ContactPage = () => (
  <div>
    <NavBar />
    <p>Contact Page</p>
  </div>
);

const App = () => {
  return <div></div>;
};

export default App;
export { HomePage, AboutPage, ContactPage };
```

Veuillez lancer votre application et v√©rifier que tout fonctionne. Lorsque vous cliquez sur un lien, le router d√©tecte qu'il y a eu un changement d'√©tat, et `element` dans la configuration du router est rappel√© pour la route associ√©e, amenant au render du composant.

# <InternalPageTitle> Utilisation de useNavigation </InternalPageTitle>

Si l'on souhaite se rapprocher du design initial, nous pouvons utiliser le hook `useNavigation` qui offre une fonction pour naviguer vers une nouvelle route.

Veuillez mettre `App` √† jour :
```jsx numbered highlighting="1,7-9"
import { useNavigate } from "react-router-dom";

const NavBar = () => {
  const navigate = useNavigate();
  return (
    <nav>
      <button onClick={() => navigate("/")}>Home</button>
      <button onClick={() => navigate("/about")}>About</button>
      <button onClick={() => navigate("/contact")}> Contact</button>
    </nav>
  );
};

const HomePage = () => (
  <div>
    <NavBar />
    <p>Home Page</p>
  </div>
);
const AboutPage = () => (
  <div>
    <NavBar />
    <p>About Page</p>
  </div>
);
const ContactPage = () => (
  <div>
    <NavBar />
    <p>Contact Page</p>
  </div>
);

const App = () => {
  return <div></div>;
};

export default App;
export { HomePage, AboutPage, ContactPage };
```

Voila, nous avons un design qui ressemble au design initial.  
N'h√©sitez pas √† tester le router : 
- Faites un reload quand vous √™tes dans la `ContactPage` pour voir que vous y restez bien.
- Naviguez sur plusieurs pages, puis utiliser les fonctionnalit√©s "Back" and "Forward" pour voyager dans l'historique de votre Browser.
- V√©rifiez bien que l'URL dans le browser correspond bien √† la page demand√©e.

üí≠ Est-ce qu'il n'y a pas quelque chose qui vous d√©range dans la solution actuelle du layout de nos pages ?

Actuellement, nous int√©grons une `NavBar` dans chaque page. Cela signifie qu'√† chaque navigation d'une page √† une autre, c'est l'enti√®ret√© de la page qui doit √™tre rendue, y compris les √©l√©ments de la `Navbar`, qui pourtant ne changent pas !

Il serait int√©ressant de pouvoir d√©finir un layout de tout ce qui devrait √™tre rendu qu'une seule fois dans notre page, comme par exemple une `Navbar`.

Pour ce faire, nous allons voir les "nested routes".

# <InternalPageTitle> Nested routes </InternalPageTitle>

Il est possible de d√©finir une route parent, √ßa serait la route "racine" ici, pour afficher le squelette de nos pages.

Ensuite, nous afficherons des routes "enfants" au sein de la route "parent". Pour indiquer o√π les routes "enfants" devront s'afficher chez le "parent", nous utiliserons un `<Outlet>`.

Voici comment d√©finir la route `/` pour le squelette de l'application qui se trouvera dans `App`, puis les 3 routes "enfants" pour les 3 pages (veuillez mettre √† jour le router au sein de `main.jsx`) :
```jsx numbered highlighting="3-18"
const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    children: [
      {
        path: "",
        element: <HomePage />,
      },
      {
        path: "about",
        element: <AboutPage />,
      },
      {
        path: "contact",
        element: <ContactPage />,
      },
    ],
  },
]);
```

Il ne nous reste plus qu'√† mettre √† jour `App` pour int√©grer le `Outlet` et pour enlever l'appel de chaque page √† la `NavBar` : 
```jsx numbered highlighting="1,15-17,21-22"
import { Outlet, useNavigate } from "react-router-dom";

const NavBar = () => {
  const navigate = useNavigate();

  return (
    <nav>
      <button onClick={() => navigate("/")}>Home</button>
      <button onClick={() => navigate("/about")}>About</button>
      <button onClick={() => navigate("/contact")}> Contact</button>
    </nav>
  );
};

const HomePage = () => <p>Home Page</p>;
const AboutPage = () => <p>About Page</p>;
const ContactPage = () => <p>Contact Page</p>;

const App = () => (
  <div>
    <NavBar />
    <Outlet />
  </div>
);

export default App;
export { HomePage, AboutPage, ContactPage };
```

Nous avons l√† un code bien propre, et une navigation parfaitement fonctionnelle !  
Il est √† noter que le code serait encore plus simple si nous utilisions le composant `Link` de la librairie (il suffirait de le styler pour qu'il ressemble √† un bouton).

# <InternalPageTitle> URL dynamiques </InternalPageTitle>

Parfois, il est int√©ressant qu'une m√™me composant soit appel√© sur toute une famille de routes. 

Par exemple, dans le composant `AboutPage`, nous souhaitons afficher une liste d'utilisateurs.  Lorsque nous cliquons sur une utilisatrice ou un utilisateur, nous souhaitons faire appel √† un nouveau composant `UserPage` qui permettra d'afficher sa page associ√©e avec comme url : `/users/:userId`.

Veuillez mettre √† jour le composant `App` pour cr√©er la `UserPage` et mettre √† jour `AboutPage` : 

```jsx numbered highlighting="19-24,29-48,50-65"
import { Link, Outlet, useMatch, useNavigate } from "react-router-dom";

const NavBar = () => {
  const navigate = useNavigate();

  return (
    <nav>
      <button onClick={() => navigate("/")}>Home</button>
      <button onClick={() => navigate("/about")}>About</button>
      <button onClick={() => navigate("/contact")}> Contact</button>
    </nav>
  );
};

const HomePage = () => <p>Home Page</p>;
const AboutPage = () => (
  <div>
    <h1>About Page</h1>
    <h2>Authors:</h2>
    {users.map((user) => (
      <Link key={user.id} to={`/users/${user.id}`} style={{ display: "block" }}>
        {user.name}
      </Link>
    ))}
  </div>
);
const ContactPage = () => <p>Contact Page</p>;

const users = [
  {
    id: 1,
    name: "John Doe",
    email: "john.doe@example.com",
    phone: "123-456-7890",
  },
  {
    id: 2,
    name: "Jane Smith",
    email: "jane.smith@example.com",
    phone: "234-567-8901",
  },
  {
    id: 3,
    name: "James Brown",
    email: "james.brown@example.com",
    phone: "345-678-9012",
  },
];

const UserPage = () => {
  const match = useMatch("/users/:userId");
  const userId = match?.params.userId;
  if (!userId) return <p>User not found</p>;

  const user = users.find((user) => user.id.toString() === userId);
  if (!user) return <p>User not found</p>;

  return (
    <div>
      <h2>{user.name}</h2>
      <p>Email: {user.email}</p>
      <p>Phone: {user.phone}</p>
    </div>
  );
};

const App = () => (
  <div>
    <NavBar />
    <Outlet />
  </div>
);

export default App;
export { HomePage, AboutPage, ContactPage, UserPage };
```

Le composant `AboutPage` contient des `Link` qui pointent vers des URL qui sont `/users/1` pour le premier user, `/users/2` pour le user qui a l'id `2`...

Pour r√©cup√©rer cette id dans la page des utilisateurs (le composant `UserPage`), nous utilisons le hook `useMatch("/users/:userId")` pour indiquer le segment dynamique de l'URL par une variable qui sera accessible via `match.params.userId`.

Pour que tout cela fonctionne, il ne reste plus qu'√† configurer le router pour cette route dynamique. Veuillez mettre √† jour la configuration du router dans `/src/main.jsx` : 
```jsx numbered highlighting="18-21"
const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    children: [
      {
        path: "",
        element: <HomePage />,
      },
      {
        path: "about",
        element: <AboutPage />,
      },
      {
        path: "contact",
        element: <ContactPage />,
      },
      {
        path: "users/:userId",
        element: <UserPage />,
      }
    ],
  },
]);
```

Veuillez v√©rifier que tout fonctionne bien, que vous pouvez afficher la page de `James Brown`.

üí≠ Il est √† noter que si nous n'avions pas voulu cr√©er une nouvelle page mais plut√¥t afficher le d√©tail d'un utilisateur dans le composant `AboutPage`, nous aurions pour cr√©er une route "enfant" de `/about` (en utilisant un `Outlet` dans `AboutPage`).

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [router-starter](https://github.com/e-vinci/ts-demos/tree/main/front/routing).

# <InternalPageTitle> Exercice 7.1 : React Router de base </InternalPageTitle>

Nous avons cr√©√© pour vous une application contenant 3 pages. Malheureusement, nous avons oubli√© de mettre en place la navigation entre ces pages... üòâ

Veuillez cr√©er un nouveau projet nomm√© `exercises/module7/7.1-2-3` sur base du starter donn√© ici : [router-starter](https://github.com/e-vinci/web3-exercises/tree/main/tutorials/router-starter).

Vous allez donc cr√©er la nouvelle application `iMovies` qui s'occupera d'int√©grer les 3 pages d√©j√† offertes en mettant en place la navigation.

Vous devez faire en sorte que chaque page poss√®de un m√™me header et un m√™me footer. Vous d√©couvrirez que le router-starter vous offre d√©j√† un composant **`Header`** et un composant **`Footer`**. Utilisez donc les biens ; )

A vous d'int√©grer le menu de navigation l√† o√π il vous semble appropri√©.


# <InternalPageTitle> Comment g√©rer l'√©tat avec React Router ? </InternalPageTitle>

Il est possible que vous ayez remarqu√©, dans le code du router du tutoriel pr√©c√©dent, qu'il semble compliqu√©, voire impossible, de faire passer des variables d'√©tats & des fonctions pour mettre √† jour cet √©tat, entre routes...

Pour la pizzeria, l'IHM que nous avons d√©velopp√©e s'est termin√©e avec le code du tutoriel `ui-library`. N√©anmoins, pour la suite du cours, nous ne souhaitons pas vous imposer d'utiliser des composants de `Material UI`. D√®s lors, nous avons restructur√© le code pour avoir quelque chose de propre, qui contient :
- que du CSS sans composants `MUI`;
- deux pages : `HomePage` & `AddPizzaPage` ; 
- un router et une `NavBar` pour assurer la navigation.
Cette nouvelle version de l'App se trouve dans le projet `routing-starter`.

Pour ce nouveau tutoriel, veuillez cr√©er un nouveau projet `router-state` sur base d'un copier/coller du projet [router-state-starter](https://github.com/e-vinci/web3-exercises/tree/main/tutorials/router-state-starter). Attention, il est normal que votre projet ne s'ex√©cute pas car il manque la gestion de l'√©tat.  
N'h√©sitez pas √† utiliser ce site pour t√©l√©charger le code du dossier router-starter : https://download-directory.github.io/

Veuillez vous assurer que vous comprenez le code associ√© au routage des pages : `main.jsx`, `App` et `HomePage` et `AddPizzaPage` sont √† bien analyser.

Pour g√©rer l'√©tat entre siblings (deux pages ici, l'√©quivalent de deux routes), nous avons appris pr√©c√©demment qu'il fallait :
- d√©clarer l'√©tat et des fonctions pour mettre √† jour cet √©tat au niveau du parent ;
- passer cet √©tat & fonctions aux enfants (les pages ici) qui vont devoir l'utiliser.

Or ici, la relation "parent/enfant" est compliqu√©e, car :
- il y a un composant `<App>` qui contient tout le squelette de l'application, pour les 2 pages de l'application ;
- il y a un composant `<Outlet>` qui s'occupe d'appeler les composants "enfants" (les pages) en fonction de la route.

Ainsi, il n'est pas vraiment possible de classiquement faire un "drill" des variables d'√©tat et des fonctions. On ne peut pas passer les variables d'√©tat, ainsi que les fonctions pour mettre √† jour cet √©tat, de `App` vers `HomePage` et `AddMoviePage`.

Il existe plusieurs fa√ßon de g√©rer de mani√®re √©l√©gante l'√©tat de l'application. Nous avons vu il y a quelques semaines **React Context**. Ici, nous allons voir ce que **React Router** met √† notre disposition sans devoir utiliser une nouvelle librairie comme **React Context**.

# <InternalPageTitle> Utilisation d'un OutletContext </InternalPageTitle>

Dans une route "parent", nous allons d√©finir un contexte √† l'aide du composant `Outlet`. Ce contexte peut √™tre n'importe quelle donn√©e ou fonction que nous souhaitons partager avec les routes "enfants".

Dans une route "enfant", nous pouvons acc√©der au contexte en utilisant le hook `useOutletContext`.

Commen√ßons par mettre √† jour `App` en y ajoutant la d√©finition et le passage du contexte aux routes "enfants" :
```jsx numbered highlighting="18-26,37"
const App = () => {
  const [actionToBePerformed, setActionToBePerformed] = useState(false);
  const [pizzas, setPizzas] = useState(defaultPizzas);

  const addPizza = (newPizza) => {
    const pizzaAdded = { ...newPizza, id: nextPizzaId(pizzas) };
    setPizzas([...pizzas, pizzaAdded]);
  };

  const handleHeaderClick = () => {
    setActionToBePerformed(true);
  };

  const clearActionToBePerformed = () => {
    setActionToBePerformed(false);
  };

  const fullPizzaContext = {
    addPizza,
    pizzas,
    setPizzas,
    actionToBePerformed,
    setActionToBePerformed,
    clearActionToBePerformed,
    drinks,
  };

  return (
    <div className="page">
      <Header
        title="We love Pizza"
        version={0 + 1}
        handleHeaderClick={handleHeaderClick}
      />
      <main>
        <NavBar />
        <Outlet context={fullPizzaContext} />
      </main>
      <Footer />
    </div>
  );
};
```

Maintenant, nous souhaitons mettre √† jour `HomePage` pour r√©cup√©rer, via le hook `useOutletContext`, le `PizzeriaContext` : 
```jsx numbered highlighting="2-7"
const HomePage = () => {
  const {
    actionToBePerformed,
    clearActionToBePerformed,
    pizzas,
    drinks,
  } = useOutletContext();

  return (
    <>
      <h1>Ma Pizzeria</h1>
      <p>
        Parce que nous aimons le JS/TS, vous pouvez cliquer sur le header pour
        d√©marrer / stopper la musique ; )
      </p>
      <AudioPlayer
        sound={sound}
        actionToBePerformed={actionToBePerformed}
        clearActionToBePerformed={clearActionToBePerformed}
      />

      <PizzaMenu pizzas={pizzas} />

      <DrinkMenu title="Nos boissons" drinks={drinks} />
    </>
  );
};
```

N'oubliez pas dans la **`HomePage`** d'importer **`useOutletContext`** : 
```jsx
import { useOutletContext } from "react-router-dom";
```

Puis, nous souhaitons aussi mettre √† jour `AddMoviePage` pour r√©cup√©rer la fonction `addPizza` du contexte : 
```tsx
const AddPizzaPage = () => {
  const { addPizza } = useOutletContext();
```

N'oubliez pas de faire l'import de `useOutletContext` et du type `PizzeriaContext`.
Une fois les changements effectu√©s, vous devriez avoir une application pleinement fonctionnelle, avec un routing moderne et une gestion √©l√©gante de l'√©tat.

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [router-state](https://github.com/e-vinci/web3-exercises/tree/main/tutorials/router-state).

# <InternalPageTitle> Exercice 7.2 : √âtat avec un router </InternalPageTitle>

Veuillez continuer votre exercice pr√©c√©dent dans le projet existant et nomm√© `exercises/module7/7.1-2-3` en y int√©grant une `AddMoviePage` qui permette d'ajouter un film √† la liste des films. Une fois un film ajout√©, l'utilisateur est automatiquement redirig√© vers la `MovieListPage`.

# <InternalPageTitle> Exercice 7.3 : Routes dynamiques </InternalPageTitle>

Veuillez continuer l'exercice pr√©c√©dent dans le projet existant et nomm√© `exercises/module7/7.1-2-3`.

Nous vous demandons : 
- De mettre √† jour la `HomePage` afin qu'elle affiche une liste reprenant uniquement les titres de vos films favoris (sans d'autres infos associ√©es aux films telles que la description...).
- Il doit √™tre possible de pouvoir cliquer sur le titre d'un de vos films favoris et de naviguer vers une nouvelle `MoviePage` qui affichera toutes les infos de ce film-ci. Pour ce faire, vous devez ajouter un id √† vos films, et cette id doit √™tre visible dans l'URL quand les utilisateurs cliquent sur un titre donn√© dans la `HomePage`.

# <a id="b"></a> b) Ant Design
## <a id="b1"></a>b.1) Introduction √† Ant Design

Nous allons √† pr√©sent int√©grer une biblioth√®que de composants React qui va nous rendre un certain nombre de services pour la conception, ainsi que la cr√©ation de notre interface utilisateur. Il en existe plusieurs, mais nous avons choisi ici de vous proposer : **Ant Design**.

Dans un premier temps, "d√©ambulez" sur le site internet https://ant.design/ [[R.9]](/references/#r9) pour vous faire une id√©e des "services" rendus par ce module (~5-10min). Vous remarquerez que **Ant Design** semble proposer plusieurs choses :

- Un ensemble de "patterns", et "principes" √† respecter pour la cr√©ation d'interfaces graphiques efficaces : [Introduction] (https://ant.design/docs/spec/introduce) [[R.9]](/references/#r9).
- Un ensemble d'outils pour vous aider dans la cr√©ation d'interfaces (application de prototypage, des templates de sites web...).
- Un ensemble de composants "pr√™ts √† l'emploi", pour la cr√©ation d'interfaces graphiques : [Components Overview](https://ant.design/components/overview/) [[R.9]](/references/#r9).

C'est sur ce dernier point que nous allons principalement travailler. 

## <a id="b2"></a> b.2) Int√©gration de Ant Design dans un projet

Veuillez cr√©er un nouveau projet dans le r√©pertoire **module7/7.4** de votre repo sur base d'un "copier / coller" du contenu de l'application d√©velopp√©e aux exercices pr√©c√©dent.

Commen√ßons par int√©grer **Ant Design** dans notre projet, au sein du r√©pertoire associ√© aux exercices pr√©c√©dents.  
Pour cela, consultez la documentation officielle [Use with Vite](https://ant.design/docs/react/use-with-vite) [[R.9]](/references/#r9). 

Veuillez faire attention √† ne pas copier simplement les commandes, mais √† bien r√©fl√©chir √† leur utilit√©, tout en lisant attentivement la documentation.  
Par exemple, inutile de faire la premi√®re commande **`npm create vite antd-demo`** car notre projet existe d√©j√†...

Ensuite, commen√ßons par changer les "input" de notre composant "**CreateNew**", en utilisant les composants "**Input**" de **Ant Design** : [Input](https://ant.design/components/input/) [[R.9]](/references/#r9).  
Pour cela, consultez la documentation officielle, en regardant plus en d√©tail les exemples, et notamment le code source associ√©. Cliquez sur l'icone "**< >**" en dessous d'un exemple pour voir le code source associ√© √† l'exemple. Pour avoir une vue compl√®te des props que vous pouvez passer au composant, consultez la section API √† la fin de la page. L'exemple "**Basic usage**" devrait nous suffire dans un premier temps.

Faisons de m√™me pour le bouton, en utilisant le composant "**Button**" de **Ant Design** : [Button](https://ant.design/components/button/) [[R.9]](/references/#r9).

Si vous le souhaitez, n'h√©sitez pas √† ajouter des petites ic√¥nes dans les boutons, des pr√©fixes sur les inputs... pour vous rendre compte de la simplicit√©.

## <a id="b3"></a> b.3) Ant Design Forms

Nous avons maintenant utilis√© nos premiers composants "externes" propos√©s par **Ant Design**. Nous allons maintenant remplacer notre balise "**form**" par le formulaire **Ant Design** qui va nous rendre beaucoup de services.

Consultons la documentation officielle du composant [Form](https://ant.design/components/form/) [[R.9]](/references/#r9), et plus particuli√®rement le "**Basic Usage**", et adaptons notre code pour en faire usage. Nous constaterons que ce composant nous rend plusieurs services :
- Validation des champs : veuillez faire en sorte que tous les champs soient requis pour l'ajout d'une anectdote.
- Gestion de l'√©tat du formulaire int√©gr√© : nous ne devons plus utiliser des "**useState()**" avec des "**onChange()**" pour contr√¥ler le formulaire.
- Gestion plus simple du submit du formulaire.
- Gestion du "**layout**" du formulaire, avec alignement des labels...

N'h√©sitez pas √† consulter les autres options possibles sur les formulaires, il y en a pour tous les cas d'utilisation...

## <a id="b4"></a> b.4) üç¨ Encore d'autres composants (optionnel)
N'h√©sitez pas √† continuer la modification de votre application en utilisant d'autres composants. 

Nous vous conseillons :
- [Layout](https://ant.design/components/layout/) [[R.9]](/references/#r9) : pour le layout de votre projet, avec un menu, un footer...
- [Message](https://ant.design/components/message/) ou [Alert](https://ant.design/components/alert/) [[R.9]](/references/#r9) pour les notifications.
- [List](https://ant.design/components/list/) ou [Table](https://ant.design/components/table/) [[R.9]](/references/#r9) pour la liste des anecdotes.

# <a id="c"></a> c) üç¨ Solution des exercices
Une solution pour les exercices de ce module se trouvent ici : [module7](https://gitlab.vinci.be/6i3-web3/2023-2024/module7.git).

Vous devez avoir un compte Vinci pour pouvoir y acc√©der.