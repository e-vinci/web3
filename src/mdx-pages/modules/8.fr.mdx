---
title: "Module 8 : SPA & sessions & d√©ploiement"
description: "Gestion de session utilisateurs pour suivre des op√©rations sur des ressources & d√©ploiement de SPA sur le cloud"
---

# Module 8 : SPA & sessions & d√©ploiement
Ce module vous offre principalement la gestion de session utilisateurs pour faciliter les op√©rations sur des ressources ainsi que le d√©ploiement de SPA sur le cloud.

Voici les sujets trait√©s :
- a) [Gestion de sessions c√¥t√© client](#a)
    - a.1) [Introduction](#a1)
    - a.2) [Persistance de donn√©es de sessions via le web storage](#a2)
    - a.3) [Persistance de donn√©es de session via des cookies](#a3)
- b) [Exercice 8.1 : Persistance de la session de myMovies dans le web storage](#b)
- c) [D√©ploiement d'applications sur le cloud](#d)
    - c.1) [Introduction](#c1)
    - c.2) [D√©ploiement d'un frontend sur GitHub Pages](#c2)
    - c.3) [D√©ploiement d'une API sur Heroku](#c3)
    - c.4) [D√©ploiement d'une API sur des providers gratuits](#c4)
- d) [Exercice 8.2 : D√©ploiement de myMovies sur le cloud](#d)
- e) [üç¨ Exercice 8.3 : l'essentiel du cours en action](#e)

# <a id="a"></a> a) Gestion de sessions c√¥t√© client

## <a id="a1"></a> a.1) Introduction
Nous avons vu qu'une des exigences associ√©es √† la cr√©ation d'une application selon l'architecture REST, c'est qu'elle soit **stateless**, c'est √† dire que l'API ne doit pas garder l'√©tat du client, sa session, c√¥t√© serveur.

C'est donc au client de sauvegarder ses donn√©es de session.

Pour rappel, nous avons d√©j√† vu les avantages et les inconv√©nients d'avoir un serveur **stateless** par rapport √† un serveur **stateful** lorsque nous avons trait√© de l'authentification : [Module 7 : a.1.4) Stateful VS stateless authentication](/modules/7/#a1.4).

Mais o√π pouvons nous sauvegarder des donn√©es de mani√®re persistantes c√¥t√© client ?

Il existe deux principales fa√ßon de sauvegarder de l'info dans un browser :
- le **web storage** ; 
- les **cookies**.

Dans le cadre de ce cours, nous allons voir comment sauvegarder de l'info √† l'aide de ces deux fa√ßons.

NB : le browser met √† disposition d'autres API un peu moins connues pour sauvegarder des infos. Nous ne les verrons pas dans le cadre de ce cours, mais il reste n√©anmoins int√©ressant de voir de quoi il s'agit :
- **IndexedDB API** : permet de sauvegarder c√¥t√© client de grandes quantit√© d'infos structur√©es, incluant des fichiers ; c'est une base de donn√©es orient√©e objets en JS qui permet les transactions.
- **Cache API** : permet d'enregistrer et retrouver des requ√™tes et leur r√©ponses. Bien qu'√† la base cr√©√© pour pouvoir fournir des r√©ponses plus rapides √† certaines requ√™tes, cette API peut aussi √™tre utilis√©e comme m√©canisme g√©n√©ral de stockage.

## <a id="a2"></a> a.2) Persistance de donn√©es de sessions via le web storage
### a.2.1 Introduction
Le **Web Storage API** fournit un m√©canisme permettant aux browser d'enregistrer des paires **cl√© / valeur** d'une mani√®re plus intuitive que l'utilisation de cookies.

Il existe deux m√©canismes au sein du web storage :
- **sessionStorage** :
    - offre un espace de stockage s√©par√© pour chaque origine pour la dur√©e de la session d'une page, tant que le browser est ouvert.
    - les cl√©s / valeurs sont enregistr√©e sous forme de string uniquement ;
    - espace de stockage plus grand qu'un cookie, ~5MB maximum ;
- **localStorage** : 
    - offre aussi un espace de stockage s√©par√© pour chaque origine, mais les donn√©es persistent quand le browser est ferm√© et r√©ouvert ;
    - espace de stockage plus grand qu'un cookie, limit√© √† ~10MB en cas de crash/restart du browser.

Les principales m√©thodes offertes par **sessionStorage** et **localStorage** sont les m√™mes. Voici quelques exemples de codes par m√©thode.

### a.2.2 setItem()
Cette m√©thode permet d'enregistrer, pour une cl√© donn√©e, la valeur associ√©e :

```js numbered {5}
const¬†STORE_NAME¬†=¬†'user';

const¬†setUserSessionData¬†=¬†(user)¬†=>¬†{
¬†¬†const¬†storageValue¬†=¬†JSON.stringify(user);
¬†¬†localStorage.setItem(STORE_NAME,¬†storageValue);
};
```

Comme le web storage est un syst√®me de cl√© / valeur qui enregistre les donn√©es sous forme de string, cela vous rappelle p-e qu'il est possible d'enregistrer des objets. 

üí≠ Comment enregistrer un objet JS sous forme de string ?  
H√© bien il suffit de le s√©rialiser, comme cela est fait dans l'exemple √† l'aide de la m√©thode **`JSON.stringify()`**.

### a.2.3 getItem()
Cette m√©thode permet d'obtenir la valeur associ√©e √† la cl√© donn√©e en argument :

```js numbered {4}
const¬†STORE_NAME¬†=¬†'user';

const¬†getUserSessionData¬†=¬†()¬†=>¬†{
¬†¬†const¬†retrievedUser¬†=¬†localStorage.getItem(STORE_NAME);
¬†¬†if¬†(!retrievedUser)¬†return;
¬†¬†return¬†JSON.parse(retrievedUser);
};
```

Pour cet exemple, comme la valeur a √©t√© s√©rialis√©e, nous pouvons r√©cup√©rer l'objet gr√¢ce √† la m√©thode **`JSON.parse()`**.

### a.2.4 removeITem()
Cette m√©thode permet d'effacer une cl√© / valeur :

```js numbered {4}
const¬†STORE_NAME¬†=¬†'user';

const¬†removeSessionData¬†=¬†()¬†=>¬†{
¬†¬†localStorage.removeItem(STORE_NAME);
};
```

### a.2.5 clear()
Cette m√©thode permet d'effacer tout l'espace de stockage pour une origine donn√©e.

Cette m√©thode est tr√®s utile lorsque l'on souhaite effacer toute la session d'un utilisateur, notamment lors du logout d'un utilisateur.

### Mise en place du localStorage pour sauvegarder les donn√©es de session

Dans le cadre du site nous permettant de g√©rer une pizzeria, nous allons faire en sorte de sauvegarder les donn√©es de session au sein du **localStorage**, et plus juste en m√©moire vive.

Veuillez d√©marrer la derni√®re version de la RESTful API de la pizzeria. En cas de souci, vous pouvez utiliser ce code-ci :
[safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

Nous allons maintenant finaliser le d√©veloppement de l'IHM [jwt-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch).

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/hmi/web-storage** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/hmi/jwt-fetch** (ou [jwt-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/hmi/web-storage**.

Afin de sauvegarder les donn√©es de session, c'est √† dire l'objet **authenticatedUser** contenant un token et un username, nous devons juste mettre √† jour le fichier **/usr/utils/auths.js** :

```js numbered {1,7,10,15-16,24}
const STORE_NAME = 'user';
let currentUser;

const getAuthenticatedUser = () => {
  if (currentUser !== undefined) return currentUser;

  const serializedUser = localStorage.getItem(STORE_NAME);
  if (!serializedUser) return undefined;

  currentUser = JSON.parse(serializedUser);
  return currentUser;
};

const setAuthenticatedUser = (authenticatedUser) => {
  const serializedUser = JSON.stringify(authenticatedUser);
  localStorage.setItem(STORE_NAME, serializedUser);

  currentUser = authenticatedUser;
};

const isAuthenticated = () => currentUser !== undefined;

const clearAuthenticatedUser = () => {
  localStorage.removeItem(STORE_NAME);
  currentUser = undefined;
};

// eslint-disable-next-line object-curly-newline
export { getAuthenticatedUser, setAuthenticatedUser, isAuthenticated, clearAuthenticatedUser };
```

Au sein de **`getAuthenticatedUser`** : 
- on fait un premier check afin d'√©viter d'aller lire dans le **localStorage** si la variable **currentUser** est d√©j√† initialis√©e.
- on parse l'utilisateur authentifi√© et s√©rialis√© qui est retrouv√© dans le **localStorage** via la cl√© **STORE_NAME**.

Au sein de **`setAuthenticatedUser`**, on s√©rialise **authenticatedUser** avant d'ajouter une paire cl√© / valeur au **localStorage**.  Ces donn√©es restent dans le browser, peu importe le nombre de fois que l'on ferme son browser. 

Dans **`clearAuthenticatedUser`**, on efface la cl√© / valeur associ√©e √† l'utilisateur authentifi√© (via la cl√© **STORE_NAME**).

Veuillez bien mettre √† jour votre code et tester l'application.  
Connectez-vous √† l'aide de l'utilisateur **manager**.  Veuillez fermer votre browser.  
Veuillez le r√©ouvrir.  
Voil√†, vous devriez automatiquement √™tre authentifi√©, veuillez observer l'√©tat de la Navbar pour vous en assurer.

üí≠ O√π puis-je observer l'√©tat des donn√©es sauvegard√©es dans le web storage de mon browser ?  
Tout en ayant la fen√™tre de votre application ouverte, via Chrome, allez dans vos outils de d√©veloppeurs : **F12**.  
Puis, dans l'onglet **Application**, vous trouverez dans **Storage** : **Local Storage** et **Session Storage**.  
Ici, nous utilisons le **Local Storage**, donc cliquez dessus, vous verrez appara√Ætre `http://localhost:8080`. Cliquez sur cette URL, et vous verrez vos donn√©es de session, quelque chose du style `{"username":"manager","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1hbmFnZXIiLCJpYXQiOjE2NjE3NjM3MDksImV4cCI6MTc0ODE2MzcwOX0.jAxH0WsOgiK5vf4QduDZ8JgTR-SKC42G9aPieV_OTOo"}`.  
N'h√©sitez pas √† faire un clic droit sur l'URL `http://localhost:8080`, puis **Clear**.  
Si vous faites ensuite un refresh de votre page, comme votre session aura √©t√© effac√©e, votre utilisateur ne sera plus connect√©. Votre Navbar afficher le menu pour un utilisateur anonyme !  
Faites ce test, c'est int√©ressant üòâ.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**web storage**".

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [web-storage](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/web-storage).
- pour l'API : [safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

## <a id="a3"></a> a.3) Persistance de donn√©es de session via des cookies
### Introduction 

Un cookie repr√©sente des donn√©es qu'un serveur envoie √† un browser.  
Le browser peut sauver ce cookie. Pour chaque requ√™te faite au serveur sur la m√™me origine (que l'origine o√π le cookie a √©t√© re√ßu), le cookie sera automatiquement envoy√© au serveur.

Il fut un temps o√π les cookies √©taient utilis√© comme un m√©canisme g√©n√©ral de stockage de donn√©es c√¥t√© client. 

üëç Actuellement, si les cookies sont utilis√©s pour sauvegarder les donn√©es de session, il faut se prot√©ger contre les attaques XSS et rendre les cookies inaccessibles au JavaScript. On utilise donc les cookies **HttpOnly** qui sont inaccessibles √† la **Document.cookie API**. 

Du coup, si des donn√©es de session doivent √™tre utilis√©e pour l'IHM, on ne peut pas se passer du **web storage** !

Pour la suite, on va donc voir :
- comment utiliser Express pour cr√©er des cookies au niveau d'une API ;
- pour rendre ces cookies inaccessibles aux attaques XSS en configurant **HttpOnly** ;
- comme les cookies sont envoy√©s automatiquement au serveur, il faudra mettre √† jour notre IHM pour ne plus envoyer le token via un authorization header. L'API va charger le token dans le cookie, et comme le cookie sera automatiquement envoy√© au serveur via le browser, l'IHM et les fetch seront plus simples. 
- l'emb√™tant dans ce que nous allons faire, c'est que comme nous allons s√©curiser le cookie, nous n'aurons pas acc√®s au username via le cookie... Nous pourrions :
    - soit toujours utiliser le web storage pour sauvegarder le username, 
    - soit accepter de ne plus afficher le nom du username et avoir aucun nouveau code √† ajouter au niveau du frontend (juste enlever les authorization header inutiles) ;
    - soit mettre √† jour l'API pour offrir une route de type **GET /users/me** qui renvoie les donn√©es d'un utilisateur √† la demande d'une requ√™te cliente. Dans ce cas-l√†, √† chaque fois que l'utilisateur ouvre le browser, la premi√®re chose √† faire serait d'appeler cette op√©ration.

Pour le tutoriel, nous avons choisi la premi√®re option. Dans vos exercices optionnels, n'h√©sitez pas √† explorer une autre option.

üí≠ Mais pourquoi s√©curiser le cookie et le rendre inaccessible au JS ?  
H√© bien, imaginez qu'un attaquant arrive √† faire une attaque XSS, via un JS malicieux, renvoyant le cookie de chaque utilisateur qui affiche le menu des pizzas...  
Via ce cookie, qui contient le token de l'utilisateur, le pirate peut se faire passer pour l'utilisateur pirat√© !  
Bon, pour la pizzeria, c'est p-e pas si grave, mais imaginez si c'est le token associ√© √† votre compte banquaire !  
Si le cookie est inaccessible au JS, il est donc impossible pour un hackeur, via du JS malicieux, d'acc√©der au token, et donc, de l'envoyer üòå.

### Gestion de session c√¥t√© client via Express pour une API
Nous allons donc cr√©er une nouvelle version de l'API sauvegardant le token d'un utilisateur au sein d'un cookie, ainsi que son username, sans que ces infos soient accessible au JS c√¥t√© client.

Pour ce faire nous allons utiliser la librairie [cookie-session](https://github.com/expressjs/cookie-session) qui permet d'enregistrer des donn√©es de session dans des cookies.

Nous allons maintenant continuer le d√©veloppement de l'API [safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/api/cookies** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/api/safe** (ou [safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/api/cookies**.

Veuillez installer la librairie **jsonwebtoken** au sein de votre nouveau projet **auths** :
```bash
npm i cookie-session
```

#### Utilisation de la fonction middleware `cookieSession`

Veuillez mettre √† jour **/app.json** pour mettre en place la gestion de cookies :

```js {4,12-23}
const express = require('express');
const cookieParser = require('cookie-parser');
const logger = require('morgan');
const cookieSession = require('cookie-session');

const usersRouter = require('./routes/users');
const pizzaRouter = require('./routes/pizzas');
const authsRouter = require('./routes/auths');

const app = express();

const expiryDateIn3Months = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30 * 3);
const cookieSecreteKey = 'YouWouldnot!not!like!mypizza';
app.use(
  cookieSession({
    name: 'user',
    keys: [cookieSecreteKey],
    cookie: {
      httpOnly: true,
      expires: expiryDateIn3Months,
    },
  }),
);

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/users', usersRouter);
app.use('/pizzas', pizzaRouter);
app.use('/auths', authsRouter);

module.exports = app;
```

Nous avons donc bien indiqu√© que le cookie est inaccessible au JS via : `httpOnly: true,`.

Nous avons fait en sorte que le cookie soit sign√© via la cl√© `cookieSecreteKey`.  
Le m√©canisme de signature correspond √† ce qui a √©t√© vu dans le cadre des tokens JWT.  
Ainsi, si un cookie venait √™tre modifi√© par un utilisateur, lors de la v√©rification du cookie, cela sera automatiquement d√©tect√© par la fonction middleware `cookieSession` et la session ne sera pas cr√©√©e.

Pour info, la fonction middleware `cookieSession` va cr√©√© deux cookies :
- un cookie portant comme nom la valeur de `name` ; il est encod√© en base64. N'h√©sitez pas √† vous amuser √† d√©coder un cookie g√©n√©r√© par `cookieSession` sur [base64decode](https://www.base64decode.org/).
- un cookie portant comme nom la valeur de `name` + `.sig` : c'est la signature qui pr√©vient contre le "tempering" (acte intentionnel mais non autoris√© qui am√®ne √† la modification d'un syst√®me ou de donn√©es).

#### Lecture et ajout de donn√©es de session via `req.session`
Pour cr√©er des donn√©es de session, il suffit de simplement les ajouter √† l'objet **`req.session`**.

Dans le cadre de la RESTful API g√©rant les pizzas, cela est fait lors d'une op√©ration de type **register** ou **login**.

Veuillez mettre √† jour le router **/routes/auths.js**

```js numbered {17,19,33,35,38-42,44-47}
const express = require('express');
const { register, login } = require('../models/users');

const router = express.Router();

/* Register a user */
router.post('/register', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Request

  const authenticatedUser = await register(username, password);

  if (!authenticatedUser) return res.sendStatus(409); // 409 Conflict

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Login a user */
router.post('/login', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Reques

  const authenticatedUser = await login(username, password);

  if (!authenticatedUser) return res.sendStatus(401); // 401 Unauthorized

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Logout a user */
router.get('/logout', (req, res) => {
  req.session = null;
  return res.sendStatus();
});

function createCookieSessionData(req, authenticatedUser) {
  req.session.username = authenticatedUser.username;
  req.session.token = authenticatedUser.token;
}

module.exports = router;
```

Dans le code ci-dessus, nous pr√©parons les donn√©es de session qui seront √©crites dans le cookie √† l'aide de l'objet `req.session`.  
Lorsque nous renvoyons du JSON aux clients, nous ne renvoyons plus le token, mais juste le username de l'utilisateur. L'application cliente, le browser, pourra utiliser cette info pour afficher le nom de l'utilisateur. Pour rappel, le browser n'a pas acc√®s, via le JS, √† l'info se trouvant dans le cookie.

Quand nous g√©rons une session via des cookies, il n'est pas √©vident de bien cl√¥re une session. Nous avons cr√©√© une nouvelle op√©ration de type **GET /auths/logout** qui permet d'effacer les donn√©es de session d'un utilisateur.

Il nous reste √† changer le m√©canisme d'autorisation.
Les tokens ne seront plus re√ßu via un authorization header, mais via un cookie.  
Nous allons donc mettre √† jour le middleware **/utils/authorize** (1 seule ligne) :
```js numbered {7}
const jwt = require('jsonwebtoken');
const { readOneUserFromUsername } = require('../models/users');

const jwtSecret = 'ilovemypizza!';

const authorize = (req, res, next) => {
  const { token } = req.session;
  if (!token) return res.sendStatus(401);

  try {
    const decoded = jwt.verify(token, jwtSecret);
    console.log('decoded', decoded);
    const { username } = decoded;

    const existingUser = readOneUserFromUsername(username);

    if (!existingUser) return res.sendStatus(401);

    req.user = existingUser; // request.user object is available in all other middleware functions
    return next();
  } catch (err) {
    console.error('authorize: ', err);
    return res.sendStatus(401);
  }
};

const isAdmin = (req, res, next) => {
  const { username } = req.user;

  if (username !== 'admin') return res.sendStatus(403);
  return next();
};

module.exports = { authorize, isAdmin };
```

#### Test de la RESTful API via REST Client
Il nous reste √† tester nos requ√™tes via REST Client.

Il n'y a pas de nouvelles notions √† apprendre pour utiliser REST Client avec des cookies : le comportement par d√©faut de REST Client est, lorsqu'un cookie est renvoy√© dans une r√©ponse, c'est d'inclure ce cookie dans chaque requ√™te vers la m√™me origine.

D√®s lors, pour tester l'API, il suffit d'enlever tous les authorization headers et de rajouter une requ√™te pour tester l'effacement d'une session.

Veuillez tester les requ√™tes √† l'aide de **/REST Client/pizzas.http** :
```js numbered {17,19,33,35,38-42,44-47}
const express = require('express');
const { register, login } = require('../models/users');

const router = express.Router();

/* Register a user */
router.post('/register', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Request

  const authenticatedUser = await register(username, password);

  if (!authenticatedUser) return res.sendStatus(409); // 409 Conflict

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Login a user */
router.post('/login', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Reques

  const authenticatedUser = await login(username, password);

  if (!authenticatedUser) return res.sendStatus(401); // 401 Unauthorized

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Logout a user */
router.get('/logout', (req, res) => {
  req.session = null;
  return res.sendStatus();
});

function createCookieSessionData(req, authenticatedUser) {
  req.session.username = authenticatedUser.username;
  req.session.token = authenticatedUser.token;
}

module.exports = router;
```

Dans le code ci-dessus, nous pr√©parons les donn√©es de session qui seront √©crites dans le cookie √† l'aide de l'objet `req.session`.  
Lorsque nous renvoyons du JSON aux clients, nous ne renvoyons plus le token, mais juste le username de l'utilisateur. L'application cliente, le browser, pourra utiliser cette info pour afficher le nom de l'utilisateur. Pour rappel, le browser n'a pas acc√®s, via le JS, √† l'info se trouvant dans le cookie.

Quand nous g√©rons une session via des cookies, il n'est pas √©vident de bien cl√¥re une session. Nous avons cr√©√© une nouvelle op√©ration de type **GET /auths/logout** qui permet d'effacer les donn√©es de session d'un utilisateur.

Il nous reste √† changer le m√©canisme d'autorisation.
Les tokens ne seront plus re√ßu via un authorization header, mais via un cookie.  
Nous allons donc mettre √† jour le middleware **/utils/authorize** (1 seule ligne) :
```http
######### NORMAL OPERATION  ###########

### Read all pizzas
GET http://localhost:3000/pizzas

### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas

### Read all pizzas sorted by title (ascending)
GET {{baseUrl}}/pizzas/?order=+title

### Read all pizzas sorted by title (descending)
GET {{baseUrl}}/pizzas/?order=-title

### Read pizza identified by 2
GET {{baseUrl}}/pizzas/2

### Create a pizza by using the admin account
#### First login as the admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Delete pizza identified by 2 with the admin token
DELETE {{baseUrl}}/pizzas/2

### Update the pizza identified by 6 with the admin token
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json

{
    "title":"Magic Green 2"
}


######### ERROR OPERATION  ###########

### 1. Create a pizza without a token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### 2. Create a pizza without being the admin, use manager account
#### 2.1 First login as the manager
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

#### 2.2 Try to create a pizza with the manager token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Read pizza which does not exists
GET {{baseUrl}}/pizzas/100

### Create a pizza which lacks a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Create a pizza without info for a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Update for a pizza which does not exist
PATCH {{baseUrl}}/pizzas/200
Content-Type: application/json

{
    "title":"Magic Green 2"
}

### Update for a pizza which does not provide any info for a property
PATCH {{baseUrl}}/pizzas/1

Content-Type: application/json

{
    "title":"Magic Green 2",
    "content":""
}
```

**/REST Client/auths.http** a √©t√© mis √† jour pour tester **GET /auths/logout** :
```http
### Logout any user
GET {{baseUrl}}/auths/logout
```

Pour ajouter une pizza, il suffit juste :
1. De loguer l'admin.
2. De cr√©er une nouvelle pizza ; le cookie est automatiquement envoy√©.

Admettons que vous souhaitez tester l'ajout d'une pizza sans envoyer de token :
1. Lancer l'op√©ration de logout (GET /auths/logout) ; le cookie renvoy√© ne contient pas de donn√©es de session ;
2. Tentez la cr√©ation d'une pizza qui renverra un code 401 Unauthorized.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**cookies api**".

En cas de souci, vous pouvez utiliser le code du tutoriel [cookies](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cookies).

### Gestion de session c√¥t√© client via une IHM et des cookies

A pr√©sent que notre API **cookies** renvoie les donn√©es de session dans un cookie non accessible par du JS, nous souhaitons mettre √† jour notre IHM pour utiliser cette API.

Nous allons repartir de la derni√®re version de notre frontend.

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/hmi/cookies** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/hmi/web-storage** (ou [web-storage](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/web-storage)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/hmi/cookies**.

Afin de sauvegarder les donn√©es de session, c'est √† dire l'objet **authenticatedUser** contenant juste un username, nous ne devons m√™me pas mettre √† jour le fichier **/usr/utils/auths.js**. En effet, l'API **cookies** renvoie un objet du genre `{username: "manager"}`. Au niveau de l'IHM, le code est donc toujours fonctionnel pour sauvegarder le username gr√¢ce √† `authenticatedUser`.

Il ne reste donc qu'√† changer le code o√π nous avons besoin d'une autorisation. Pour l'application de gestion de la pizzeria, il s'agit de la cr√©ation de pizza.  
Veuillez donc mettre √† jour **/src/Components/AddPizzaPage.js** en enlevant ces deux lignes :
- l'authenticatedUser : `const authenticatedUser = getAuthenticatedUser();` et l'import associ√© (`import { getAuthenticatedUser } from '../../utils/auths';`),
- la ligne s'occupant de l'authorization header : `Authorization: authenticatedUser.token`.

Veuillez tester votre derni√®re version du frontend.
Loguez-vous avec l'utilisateur **admin** (et le password **admin**).  
Ajoutez une pizza et v√©rifiez qu'elle s'affiche bien.  

üí≠ Comment v√©rifier le cookie ?
Tout en ayant la fen√™tre de votre application ouverte, via Chrome, allez dans vos outils de d√©veloppeurs : **F12**.  
Puis, dans l'onglet **Application**, cliquez sur **Cookies**, vous verrez appara√Ætre `http://localhost:8080`. Cliquez sur cette URL, et vous verrez vos 2 cookies de session, **user.sig** et **user**.  
N'h√©sitez pas √† aller d√©coder la valeur du cookie **user** sur [base64decode](https://www.base64decode.org/) en faisant un copier / coller de **Value**. Vous devriez voir quelque chose appara√Ætre du style `{"username":"manager","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1hbmFnZXIiLCJpYXQiOjE2NjE3NzUxMDgsImV4cCI6MTc0ODE3NTEwOH0.sAZqq6vbrjCCZZoLH-n8hJKBoXJJJ8jEoupk8xKu5WI"}`  !

Toujours dans l'onglet **Application** des outils de d√©veloppeurs de Chrome, faites un clear des cookies : clic droit sur `http://localhost:8080`, **Clear**.  
Tentez maintenant d'ajouter une pizza... Ca ne fonctionne plus, et c'est bien normal, car il n'y a plus de token qui est envoy√© √† l'API !  

Suite √† ces tests, si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**cookies hmi**".

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [cookies](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/cookies).
- pour l'API : [cookies](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cookies).

üí≠ Notons que cette version de notre frontend pourrait √™tre am√©lior√©e. Actuellement, lorsqu'on fait un logout, on n'efface pas le cookie du browser.  
Comment feriez vous ? Vous pourriez par exemple appeler la m√©thode **GET /auths/logout** üòâ.

# <a id="b"></a> b) Exercice 8.1 : Persistance de la session de myMovies dans le web storage
Lors de l'exercice pr√©c√©dent (Exercice 7.2), vous aviez une application qui permet de bien g√©rer des films, √† l'exception du fait que quand vous fermez votre browser, vous devez √† chaque fois vous reconnecter.

Veuillez faire en sorte que vos donn√©es de session soient sauvegard√©es :
- dans le **localStorage** si l'on clique sur une checkbox "Remember me" du login ou du register.
- dans le **sessionStorage** si l'on ne clique pas sur la checkbox "Remember me" lors du login ou du register.

Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :
- Veuillez d√©marrer votre API d√©velopp√©e pr√©c√©demment : **/exercises/module7/7.2/api**.
- Pour le frontend, utilisez le contenu de votre r√©pertoire d'exercices **/exercises/module7/7.1/hmi** comme point de d√©part pour cr√©er, dans votre repository local et
votre web repository (normalement appel√© **web2**), le r√©pertoire nomm√©
**/exercises/module8/8.1/hmi**.
-	Veuillez utiliser le proxy de votre frontend afin de contourner les probl√®mes associ√© √† la gestion des CORS.


#### ü§ù Tips
Cet exercice est l'application du tutoriel vu dans ce module-ci. N'h√©sitez pas donc √† rejouer les √©tapes vues dans le tutoriel au niveau de votre API : [a.2) Persistance de donn√©es de sessions via le web storage](#a2).

Vous allez aussi pouvoir refaire un petit peu de gestion d'√©v√©nements pour d√©tecter les clics sur une checkbox.

Veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 8 : web storage**"".

NB : Le code de vos applications se trouve dans votre repository local et
votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√©
**/exercises/module8/8.1/hmi**.

# <a id="c"></a> c) D√©ploiement d'applications sur le cloud
## <a id="c1"></a> c.1) Introduction
Il existe √©norm√©ment de possibilit√©s pour d√©ployer une application web, pour la rendre disponible sur le web.  
Pour certains, il s'agit d'un m√©tier √† part enti√®re, √† des administrateurs r√©seaux ou des responsables de l'architecture.  
Mais de plus en plus, avec l'avanc√©e des services sur le cloud, les d√©veloppeurs prennent un r√¥le important dans le d√©ploiement des applications.

Voici un diagramme qui exprime bien les diff√©rentes fa√ßons de d√©ployer une applications :

<ScrollableImage name="deployment.png" minWidth="600px" maxWidth="881x" />
<figcaption>Diff√©rents types de d√©ploiement d'application [R.65]</figcaption>

Sur ce diagramme, tout √† gauche, nous sommes enti√®rement responsable de la mise √† disposition de l'infrastructure. Il faut donc d'√©normes connaissances r√©seaux, au niveau OS, afin de mettre √† disposition des serveurs, les s√©curiser,...

Lorsqu'on va vers la droite du diagramme, on passe vers la d√©mat√©rialisation des services, vers le cloud, qui offre principalement trois types de services :
- **IaaS** ou Infrastructure as a Service : nous recevons toute l'infrastructure, nous devons encore nous occuper du reste, la gestion d'un OS (Linux, Windows...), les bases de donn√©es, les applications et leurs donn√©es ; Amazon Web Services, Microsoft Azure, Google Cloud, OVHcloud offrent ce genre de services...
- **PaaS** ou Platform as a Service : nous recevons tout ce qu'il faut pour simplement d√©velopper des applications ; heroku, Amazon Web Services, Microsoft Azure, Google Cloud, OVHcloud offrent ce genre de services...
- **SaaS** ou Software as a Service : nous recevons des applications pr√™tes √† √™tre utilis√©es ; office 365 est un exemple, Github en est un autre.

Lorsque nous allons d√©ployer nos RESTful API, nous allons donc tr√®s souvent utiliser un **PaaS**. En effet, voici les √©tapes principales pour le d√©ploiement :
- cr√©er et configurer le type d'application que nous allons d√©ployer avec les outils offerts par le provider : indiquer que nous souhaitons d√©velopper une application **Node.js** ;
- cr√©er un git repository pour chaque projet et faire un push des sources de notre application via les outils offerts par le provider ;
- build et d√©ploiement automatique de l'application faits par les outils du provider, sur une URL de d√©veloppement offerte par le provider.

Chaque provider va fournir une recette de cuisine pour pouvoir d√©ployer une application. Il est donc important de trouver la bonne documentation d√©crivant toutes les √©tapes.

Pour d√©ployer le frontend d'une SPA, les √©tapes principales sont similaires au d√©ploiement d'une RESTful API. N√©anmoins, il existe des outils qui permettent de faciliter le d√©ploiement du frontend d'une SPA car ce sont juste des assets √† partager sur le web, il n'y a pas d'intelligence √† fournir c√¥t√© serveur pour g√©n√©rer du contenu.  
Du coup, on peut utiliser des CDN (Content Delivery Network), des groupes de serveur qui travaillent ensemble pour fournir nos assets de mani√®re extra rapide sur Internet.  
Comme Github offre ce service via **Github Pages**, que c'est gratuit si vous acceptez que votre code source soit publique, c'est un service id√©al pour notre frontend.  
Il faut juste faire attention que votre frontend n'utilise pas de proxy pour contacter votre RESTful API, il doit le faire directement. L'API devra donc g√©rer les CORS pour autoriser l'URL associ√©e √† votre frontend !

Pour d√©ployer nos RESTful API, le facteur principal que nous souhaitons mettre en avant dans ce cours, c'est de b√©n√©ficier d'un service gratuit. Comme nous √©tudions le JS, nous consid√©rons que nous n'avons pas encore besoin d'un h√©bergement offrant de grandes performances. Nous souhaitons juste quelque chose qui nous permette de tester, sur le web, nos applications web, et les partager avec quelques dizaines de personnes. Pour le frontend, via **Github Pages**, nous avons trouv√© un service de qualit√©, partageable avec des milliers de personnes. Par contre, pour h√©berger une API, les services gratuits tendent √† dispara√Ætre.  
Avant l'automne 2022, **Heroku** fournissait un service gratuit qui √©tait parfait pour nos API. Mais ce service va dispara√Ætre. Il y a un petit espoir qu'Heroku mette un "Student Program" en place, mais rien de s√ªr.

Du coup, pour construire une API, il semblerait qu'il ne reste plus que des services qui soient que temporairement gratuits. Le souci avec ce genre de services, c'est que m√™me si c'est gratuit, on vous demande votre carte de cr√©dit, afin de "v√©rifier que vous n'√™tes pas un robot" ü§ñ !

Nous avons donc tent√© de s√©lectionner un service gratuit, temporaire, qui ne demande pas de carte de cr√©dit.

## <a id="c2"></a> c.2) D√©ploiement du frontend sur GitHub Pages
Si vous n'utilisez pas de proxy dans votre frontend mais que vous faites des requ√™tes vers votre RESTful API en utilisant directement son nom de domaine, il est tr√®s simple d'utiliser **Github Pages**. 

Votre RESTful API doit donc elle aussi √™tre d√©ploy√©e et vous devez utiliser son URL pour tous les fetch que vous faites. Pensez donc √† centraliser la configuration de l'URL associ√©e √† votre API au sein du code de votre frontend.

Vous trouverez la recette de cuisine pour d√©ployer votre frontend sur [GitHub Pages](https://pages.github.com/).

## <a id="c3"></a> c.3) D√©ploiement d'une API sur Heroku
### c.3.1) Introduction
D√®s le 28 novembre 2022, les "free Heroku Dynos" ne seront plus disponibles.  
Il y a malgr√© tout un espoir que pour les √©tudiants, un programme soit mis √† disposition. L'info sera rendue disponible en fin septembre : [Heroku"s Next Chapter](https://blog.heroku.com/next-chapter).

### c.3.2) Proc√©dure "maison"
Sur le site d'Heroku, il existe beaucoup de documentation pour apprendre √† d√©ployer √† l'aide de leurs outils.

Comme il n'est pas si facile de s'y retrouver, voici ci-dessous un r√©sum√© des √©tapes importantes via une proc√©dure "maison".

**Pr√©paration de votre application**

1. Utilisez les bonnes variables d'environnement dans Node.js en v√©rifiant que **`process.env.PORT`** est bien √©crit dans `/bin/www`.  
*La variable d'environnement `PORT`, accessible sous Node via `process.env.PORT` , est allou√© par Heroku lors du d√©marrage de l'application. Pour `HOST`, le plus simple est de ne pas en avoir : votre serveur √©coute sur toutes les IP. C'est ce qui est fait par d√©faut lorsqu'une application Express est g√©n√©r√©e.*
2. V√©rifiez **`package.json`** : Le script "start" sera ce que heroku lance en 1er.  
*Il n'y a normalement rien √† faire, `package.json` doit contenir pour "start" :*
``` json
"scripts": {
"start": "node ./bin/www" },
```
3. Cr√©ez un nouvelle app sur Heroku en vous rendant sur [HEROKU](https://www.heroku.com/), **Sign up** puis via le "Heroku dashboard" : **New**, **Create**, **New app**.  
*Donnez un nom √† votre Heroku app qui soit associ√© √† votre API.*
4. Installez le heroku buildpack pour node ; via le "Heroku dashboard", **Settings**, **Add buildpacks**, **nodejs**.  
*L'URL g√©n√©r√©e pour le buildpack est "heroku/nodejs".*
5. Configurez vos variables d'environnement au sein d'Heroku.   
*Si vous n'avez pas de secrets au niveau de votre API, pas de base de donn√©es ou autres services, vous n'avez rien √† faire √† cette √©tape-ci. Sinon, voici la documentation : [Configuration and Config Vars](https://devcenter.heroku.com/articles/config-vars).*

**Push de votre application sur Heroku √† l'aide de votre git local**

1. Allez dans le repo de votre application
2. Ajoutez une remote vers le repo de votre Heroku app :
  - Option a) avec heroku CLI : 
``` bash
npm install -g heroku
heroku login
heroku git:remote -a [your_app_name]
```  
  - Option b) sans heroku CLI, directement avec Git : 
``` bash
git remote add heroku https://git.heroku.com/[your_app_name].git
``` 
3. Faites un push de la branche en cours vers le master sur Heroku :
``` bash
git push heroku master
``` 
*Si votre branche en cours n'est pas le master :* 
``` bash
git push heroku [branche_en_cours]:master [-f]
``` 
*-f si la branche locale est fort diff√©rente du contenu sur Heroku.*

**Acc√®s √† votre API via le browser**

Soit **Open app** via "Heroku dashboard", soit vous pouvez directement taper dans le browser : **[your_app_name.herokuapp.com**.


## <a id="c4"></a> c.4) D√©ploiement d'une API sur des providers gratuits
Voici une liste de providers qui pourraient √™tre int√©ressants pour vos d√©ploiements :
- [Microsoft Azure](https://azure.microsoft.com/en-us/free/) : 
  - Vous √™tes √©tudiant ? Il semblerait que vous puissiez b√©n√©ficier de 100$ de cr√©dit et vous n'avez pas besoin de carte de cr√©dit ! Rendez-vous sur [free with Azure for Student](https://azure.microsoft.com/en-in/free/students/). **Azure App Service** semble √™tre gratuit pour 10 apps √† vie !
  - Vous n'√™tes plus √©tudiant ? services gratuits, certains toujours gratuits, d'autres pendant 12 mois, 200$ de cr√©dit pendant 30 jours. Malheureusement il faut une carte de cr√©dit pour vous faire autoriser... **Azure App Service** semble √™tre gratuit pour 10 apps √† vie ! [Documentation d'App Service](https://docs.microsoft.com/en-us/azure/app-service/) et [App Service pricing](https://azure.microsoft.com/en-us/pricing/details/app-service/linux/).
- [platform.sh](https://platform.sh/pricing/) : service gratuit pendant 30 jours, pas besoin de carte de cr√©dit.
- [Google Cloud](https://cloud.google.com/pricing) : service offrant 300$ de cr√©dit, pendant 90 jours, il faut une carte de cr√©dit üò®, mais pas de charges sauf si upgrade manuel vers un compte payant.

# <a id="d"></a> d) Exercice 8.2 : D√©ploiement de myMovies sur le cloud
Tout est dit dans le titre üòâ.

Pour le frontend, veuillez utiliser GitHub Pages.

Pour le backend, si vous √™tres √©tudiant, nous vous recommandons de vous inscrire sur Azure en tant que **student** pour obtenir vos 100$ de cr√©dit, sans carte de cr√©dit.

#### ü§ù Tips
Pensez √† cr√©er un repository pour votre frontend et un repository pour votre backend.  
La racine de vos repositories doivent correspondre √† la racine de vos projets. Pour vous en assurer, √† la racine de chaque repo, doit se trouver un fichier `/packages.json`.

‚ö° Attention, Git ne traque pas les repos dans les repos. Ainsi, vos deux projets ne peuvent pas se trouver dans le repos **web2** de votre cours !  
N'oubliez pas d'inclure un fichier **.gitignore** pour √©viter de mettre en configuration **node_modules** !

# <a id="e"></a> e) üç¨ Exercice 8.3 : D√©ploiement de myMovies sur le cloud
## e.1) Introduction
Voici un exercice qui fait revoir les comp√©tences essentiels de ce cours de JS. Il a √©t√© utilis√© comme examen pour les √©tudiants de Vinci en deuxi√®me ann√©e de bachelier en Informatique de Gestion en ao√ªt 2022. 

Normalement, cette exercice, d√©coup√© en trois questions, devrait se r√©aliser dans un d√©lai de 3h.

Veuillez t√©l√©charger ce fichier
<LinkFile name="examen_js.zip" target="_blank" download>examen_js.zip</LinkFile>.
Cette archive contient un boilerplate pour chaque question et les ressources √† utiliser pour cet examen.

Dans un premier temps, veuillez d√©sarchiver **examen_js.zip** localement sur votre machine.  
‚ö° Veuillez √©viter de le faire sur un r√©pertoire qui est partag√© sur le cloud. En effet, il y a des milliers de fichiers associ√©s aux **node_modules** lorsque vous lancerez l'installation des packages ! Une vraie horreur √† synchroniser üò® !

## e.2) Objectif
Nous allons d√©velopper deux frontends et une API pour une agence de voyages.

## e.3) Question 1 : Cr√©er une IHM interactive & moderne
Nous souhaitons afficher des lieux de vacances propos√©s par l'agence de voyages. Il y a 5 lieux diff√©rents, chacun avec un id, un nom et une image.

Le boilerplate pour cette question se trouve dans **/question1**.
Vous trouverez 5 images correspondant √† chaque lieu dans le r√©pertoire **/question1/src/img**, ainsi qu'un fichier contenant une liste des lieux avec leur id, leur nom et leur image dans **/question1/src/utils/places.js**.

Vous devez cr√©er deux pages :
-	La page d'accueil, accessible avec l'URI "/" ou avec un lien nomm√© "Home" dans la barre de navigation, doit afficher une liste de tous les noms de lieux de vacances.
-	La page de photos, accessible avec l'URI "/photos" ou avec un lien nomm√© "Photos" dans la barre de navigation, doit afficher un carrousel des lieux propos√©s.
  - Lorsqu'on arrive sur la page initialement, la page doit afficher le 3√®me lieu dans la liste, avec son image et son nom en dessous.
  - La page doit √©galement afficher deux boutons. Le premier permet d'afficher le lieu pr√©c√©dent dans la liste √† la place de celui-ci. Et  l'autre permet d'afficher le lieu suivant. Ces boutons ne doivent pas √™tre cliquables s'il n'y a plus de lieu suivant ou de lieu pr√©c√©dent dans la liste.

Contraintes d'impl√©mentation : 
-	Veuillez utiliser le fichier **/question1/src/utils/places.js** qui reprend des lieux de vacances. Vous devez mettre √† jour ce fichier pour pouvoir l'utiliser dans votre code JS comme module.
-	Aucune autre page ne doit √™tre disponible sur le site web.
-	Vous devez impl√©menter le carrousel vous-m√™me, vous ne pouvez pas utiliser un carrousel de Bootstrap.
-	Utilisez les images import√©es statiquement dans la liste des lieux de vacances et changez la source de l'image affich√©e quand l'utilisateur clique sur un bouton.

Voici un exemple de ce √† quoi pourrait ressembler votre site web :

<ScrollableImage name="places.png" minWidth="800px" maxWidth="1599x" />

<ScrollableImage name="carousel.png" minWidth="800px" maxWidth="1599x" />

## e.4) Question 2 : Cr√©er un service web
Nous souhaitons d√©velopper une RESTful API pour g√©rer les lieux de vacances propos√©s par l'agence, les utilisateurs du site, ainsi que les lieux favoris de ces utilisateurs.

Le boilerplate pour l'API de cette question se trouve dans **/question2**, c'est une copie du boilerplate du cours.

Veuillez cr√©er les op√©rations suivantes :
-	**Cr√©er un nouveau lieu de vacances**. L'op√©ration doit prendre en entr√©e le nom du lieu ainsi que sa description, et doit retourner l'ID du lieu cr√©√© au format JSON. L'op√©ration doit renvoyer une erreur si le nom ou la description ne sont pas fournis.
-	**Cr√©er un nouvel utilisateur**. L'op√©ration doit prendre en entr√©e le nom de l'utilisateur ainsi que son adresse mail, et doit retourner l'ID de l'utilisateur cr√©√© au format JSON. L'op√©ration doit renvoyer une erreur si le nom ou l'adresse mail ne sont pas fournis, ainsi que si un utilisateur existe d√©j√† pour cette adresse mail.
-	**Ajouter un lieu √† ses favoris**. L'op√©ration doit prendre en entr√©e l'ID de l'utilisateur et l'ID du lieu qu'il souhaite ajouter en favori. L'op√©ration doit renvoyer une erreur si aucun utilisateur ne correspond √† l'ID d'utilisateur donn√©, si aucun lieu ne correspond √† l'ID de lieu donn√©, ou si cet utilisateur a d√©j√† ce lieu dans ses favoris.

Vous devez √©galement cr√©er dans le fichier **/question2/RESTClient/tests.http** au minimum une requ√™te par op√©ration que vous devez impl√©menter. Vous pouvez √©galement cr√©er plus de tests si vous le souhaitez.

Contraintes d'impl√©mentation :
-	L'API que vous devez cr√©er doit correspondre aux principes d'une API RESTful.
-	Votre API ne peut pas proposer d'autres op√©rations que celles d√©crites ci-dessus.
-	Les ID que g√©n√®rent votre API doivent provenir du package **uuid**.
-	Les demandes qui sont cr√©√©es doivent persister et donc survivre au red√©marrage de votre application. Vous pouvez faire persister les demandes c√¥t√© serveur de la mani√®re que vous voulez, du moment que cela soit en JSON. N'h√©sitez pas √† utiliser **/question2/utils/json.js**.
-	Aucune autorisation JWT est n√©cessaire.

## e.5) Question 3 : Cr√©er une SPA int√©grant une IHM et un web service
Gr√¢ce √† l'API que nous avez d√©velopp√© dans la question 2, l'agence de voyages a pu am√©liorer son API pour proposer un syst√®me de recommandations. Cependant, cette API utilise un syst√®me d'Intelligence Artificielle complexe et les op√©rations qui r√©cup√®rent les recommandations peuvent prendre un certain temps. 

Le boilerplate pour cette question se trouve dans **/question3**.
Vous devez consommer l'API d√©crite ci-dessous et disponible √† l'adresse https://binv2150-aout2022.herokuapp.com pour afficher des recommandations de lieux de vacances. Cette API accepte les requ√™tes venant de toutes les origines et n'a pas de probl√®me de CORS. Vous ne devez donc pas utiliser de proxy pour consommer cette API.

| M√©thode HTTP | URI | Op√©ration | Format |
|---|---|---|---|
| **GET** | **/places**| R√©cup√©rer tous les lieux de vacances | Renvoie : `[ { id, name } ]` |
| **GET** | **/recommended** | R√©cup√©rer le lieu de vacances le plus appr√©ci√© | Renvoie : `{ id, name }` |

Sur la page d'accueil du site web, veuillez afficher le nom de tous les lieux de vacances, renvoy√©s par l'API avec l'URI "/places" (il n'est pas n√©cessaire d'afficher leur ID). 

Toujours sur la page d'accueil, veuillez √©galement afficher le nom du lieu de vacances le plus appr√©ci√©, renvoy√© par l'API avec l'URI "/recommended". Comme cette op√©ration peut prendre un certain temps, elle ne peut pas ralentir le chargement de la page. Le reste de la page doit √™tre affich√© avant de consommer cette API, et son r√©sultat doit √™tre rajout√© sur la page quand l'op√©ration est termin√©e.

Aucune autre page ne doit √™tre disponible sur le site web. Pensez donc √† effacer le code du boilerplate qui est inutile.
