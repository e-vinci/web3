---
title: "Module 2 : React state"
description: "React state"
---
import 'bootstrap/dist/css/bootstrap.min.css';

# Module 2 : React state
Ce module vous offre principalement la d√©couverte de la gestion des √©v√©nements en React, ainsi que la gestion des √©tats.

**Voici les sujets trait√©s :**
- a) [Pr√©paration de l'exercice](#a)
  - a.1) [Depuis le cours en ligne](#a1)
  - a.2) [Remarques g√©n√©rales](#a2)
- b) [Utiliser les √©v√©nements](#b)
- c) [Sauvegarder le compteur !](#c)
- d) [üç¨ Votre premier Hook custom !](#d)
- e) [A retenir](#e)
- f) [Solution des exercices](#f)

**Voici les lectures indispensables pour suivre ce module :**
- Pr√©requis, √† revoir attentivement : [JavaScript](https://fullstackopen.com/en/part1/java_script) [[R.1]](/references/#r1)
- Nouvelle mati√®re : [Component state, event handlers](https://fullstackopen.com/en/part1/component_state_event_handlers) [[R.1]](/references/#r1)


# <a id="a"></a>a) Pr√©paration de l'exercice

## <a id="a1"></a>a.1) Depuis le cours en ligne

* Dans votre dossier `/exercises` de votre repo local, lancez la commande : `npx create-react-app module2`
* Supprimez tout le contenu du dossier `src/`.
* Comme pour la semaine pr√©c√©dente, n'oubliez pas de supprimer le dossier `.git`.
* Copiez le fichier `jsconfig.json` et `src/index.js` depuis le dossier de l'exercice du module pr√©c√©dent.
* Introduisez les composants **App**, **Display**, et **Button** en copiant le contenu du cours en ligne. N'oubliez pas que chacun d'entre eux doit √™tre dans un dossier qui porte le m√™me nom que le composant : `src/components/[componentName]/[componentName].jsx`.
* V√©rifiez que les 3 boutons fonctionnent correctement : **increase**, **decrease**, **reset**.

Veuillez faire un **commit** de votre code avec le message suivant : "**module2 : init**".

## <a id="a2"></a> a.2) Remarques g√©n√©rales

* Gardez la partie jsx la plus simple possible, d√©finissez toujours des "helper functions" et "helper variables" avant le **JSX**.
* Nommez vos "event handlers" avec des pr√©fixes, par exemple : **handleXXX** ou **onXXX**. Ceci va vous permettre de vous souvenir que ces m√©thodes re√ßoivent un unique param√®tre "event" (ou e). N'utilisez pas ces pr√©fixes pour vos m√©thodes "business" qui re√ßoivent des param√®tres "normaux".  
üëç En React, g√©n√©ralement la convention est d'utiliser **`on[Event]`** comme nom pour des props qui repr√©sentent des √©v√©nements et **`handle[Event]`** pour les m√©thodes qui g√®rent ces √©v√©nements.

# <a id="b"></a>b) Utiliser les √©v√©nements

Dans cet exercice, toujours dans `/exercises/module2`, l'objectif va √™tre de supprimer les m√©thodes `increaseByOne()`... et les remplacer par une unique m√©thode `changeCount(delta)` qui va prendre un "delta" en param√®tre. Ce delta va √™tre ajout√© au compteur, et donnera la nouvelle valeur. Par exemple, un appel `changeCount(1)` va ajouter 1 au compteur, un appel √† `changeCount(-10)` va ajouter -10 au compteur ce qui √©quivaut √† supprimer 10 du compteur.

Pour cela, commencez par ajouter une prop **delta** dans le composant **Button**. Utilisez ce **delta** que vous recevez dans votre composant pour remplir l'attribut HTML **data-delta** du bouton. N'h√©sitez pas √† aller lire [la documentation MDN sur les "data attributes"](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes) [[R.5]](/references/#r5).

Supprimez les m√©thodes `increaseByOne()`, `decreaseByOne()`, et `setToZero()` du composant **App**. Et √©crivez cette m√©thode `changeCount(delta)`. Elle prend un nombre en param√®tre, et met √† jour le compteur en fonction du **delta** pass√© en param√®tre.

Jusqu'ici, les Button recevaient en props un texte √† afficher (tr√®s bien, c'est √† garder), mais √©galement une fonction `onClick` qui permettait de r√©agir au clic sur le bouton. Supprimez cette prop, et passez plut√¥t en param√®tre la fonction `changeCount` que vous avez cr√©√©e, et le **delta** qui doit √™tre associ√© au bouton :
* Incr√©menter : +1
* D√©cr√©menter : -1
* Reset : -counter

R√©cup√©rez la prop **changeCount** dans le component **Button** et √©crivez une "helper function" **`handleClick(e)`** qui va extraire la valeur de l'√©l√©ment cliqu√© (`e.target.dataset.delta`) et appeller **changeCount** avec le bon delta.

**Remarques/consignes :**
* N'UTILISEZ PAS la prop **delta** dans **handleClick**, utilisez uniquement l'√©v√©nement que vous recevez en param√®tre.
* N'oubliez pas d'utiliser **parseInt()** pour parser la valeur que vous recevez. L'op√©rateur **+** sur une cha√Æne de caract√®res fait une concat√©nation en JS.
* Les props React ne sont pas des attributs HTML, elles conservent leur types, alors que les attributs HTML sont s√©rialis√©s dans le HTML et sont donc toujours des string. Dans notre cas ici, le data-attribute **delta** qu'on a √©crit sur notre "button" HTML a donc √©t√© s√©rialis√© sous forme de string. Quand on le r√©cup√®re avec **`e.target.dataset.delta`**, il est donc bien au format string. Il faut donc le parser.

Veuillez faire un **commit** de votre code avec le message suivant : "**module2 : events**".

üí≠ Maintenant que vous avez termin√© cet exercice, remarquez qu'on aurait pu faire mieux, et beaucoup plus propre !  
Pourquoi passer par un data-attribute pour transmettre le delta, alors qu'on peut r√©-utiliser directement la prop delta dans le handleClick ?  
La r√©ponse ici est simple, juste pour l'exercice üòâ  
Gr√¢ce √† √ßa, vous avez appris qu'utiliser des attributs HTML directement nous fait perdre le type, qu'il faut parser le r√©sultat, et que ce n'est pas une bonne mani√®re de faire üòâ.

# <a id="c"></a>c) Sauvegarder le compteur

Pour cet exercice, toujours dans `/exercises/module2`, dans le composant **App**, appelez `localStorage.setItem("counter", JSON.stringify(counter))` √† chaque fois qu'on change le compteur. Dans notre cas ici, c'est juste apr√®s l'appel √† la m√©thode `setCounter` dans `changeCount`.

Ensuite, dans le `useState(0)`, au lieu de donner **0** comme valeur initiale au compteur, essayez de lire la valeur du compteur depuis le localStorage `JSON.parse(localStorage.getItem("counter"))` et passez la au `useState` comme valeur par d√©faut. Rafraichissez votre page apr√®s le changement du compteur, et constatez qu'il √† √©t√© persist√©.

Vous remarquerez cependant qu'il y a un souci avec la valeur du compteur qui est persist√©e. Il y a bien une persistance qui est faite, mais la valeur n'est pas correcte... Essayez de r√©fl√©chir √† la question, √©ventuellement en lisant la documentation officielle de React sur le hook **useState** : [Using the State Hook](https://reactjs.org/docs/hooks-state.html) [[R.6]](/references/#r6) ou sur le Render des composants : [Rendering Elements](https://reactjs.org/docs/rendering-elements.html) [[R.5]](/references/#r5).

Vous avez r√©fl√©chi √† la question ? V√©rifiez ci-dessous si vous avez trouv√© la "bonne" r√©ponse...

**======= SPOILER =======**

Au cas ou vous ne l'auriez pas compris, lorsque l'√©tat d√©fini gr√¢ce au **useState** vient √† changer, React re-render les composants qui sont impact√©s par ce changement. La seule mani√®re pour nous de changer la valeur du compteur, s'est d'utiliser le `setCounter()` que le **useState** nous √† donn√©. L'appeler en donnant une nouvelle valeur va relancer un render. Mais React ne fait pas un render √† chaque changement d'un √©tat dans notre application. Il va optimiser les render pour √©viter d'en faire √† tout bout de champ. Le render sera fait quant il veut, sans que vous sachiez exactement quand... Du coup, √† la ligne juste apr√®s votre appel √† `setCounter`, vous utilisez la valeur du counter en pensant qu'elle a √©t√© chang√©e, mais en fait, React ne la changera qu'au prochain render... Donc pas tout de suite ! Il faut donc trouver une petite parade ;-)

**======= FIN SPOILER =======**

Une fois que tout est en ordre, que le refresh n'alt√®re en rien la valeur du compteur affich√©e, 
veuillez faire un **commit** de votre code avec le message suivant : "**module2 : localStorage**".

# <a id="d"></a>d) üç¨ Votre premier Hook custom ! *(Exercice facultatif, pour les plus motiv√©s)*

Vous aurez remarqu√© que ce code n'est pas tr√®s propre... A chaque appel de `setCounter()`, il ne faudra surtout pas oublier d'√©crire dans le localStorage... Et il faudra faire √ßa, pour chaque variable qu'on veut persister... Autant dire que c'est copier/coller du code partout, et le risque d'erreur est √©norme...

Et pourquoi ne pas faire notre propre **useState**, mais qui √©crit dans le localStorage au passage ?

Ecrivez un fichier **src/hooks/useLocalStorage.js** (notez l'extension **.js** et pas **.jsx**).  
Ce fichier doit d√©clarer et exporter une fonction **`useLocalStorage(key, initialValue)`**.  
Cette fonction utilisera en son coeur la fonction **useState** et comme elle, renverra une valeur et un setter. En plus de cela , elle stockera la valeur actuelle dans le localStorage √† l'indice de la clef donn√©e et chargera la valeur stock√©e initialement. Si la clef n'existe pas dans le localStorage, cette fonction initialisera la clef avec la valeur pass√©e en second param√®tre.

Veuillez faire un **commit** de votre code avec le message suivant : "**module2 : custom hook**".

# <a id="e"></a>e) A retenir

* **useState** permet de stocker un √©tat et de "rerender" les composants automatiquement quand c'est n√©cessaire.
* Les **props** sont la principale mani√®re de passer des donn√©es ET des fonctions.
* Chaque Component doit √™tre dans son dossier.
* Les fonctions de gestion d'√©v√©nements recoivent un unique param√®tre "**e**" qui repr√©sente l'√©v√©nement. Elles portent un nom qui commence par "handle" ou "on" afin de les identifier facilement.
* Les fonctions de gestion d'√©v√©nements sont dans le composant qui g√©n√®re l'√©v√©nement. Mais elles sont souvent de simples wrapper vers des fonctions "m√©tiers" re√ßue via les props.
* Les fonctions m√©tiers viennent du composant **App**.

# <a id="f"></a> f) üç¨ Solution des exercices
Une solution pour les exercices de ce module se trouvent ici : [module-2](https://gitlab.vinci.be/6i3-web3/2022-2023/module-2.git).

Vous devez avoir un compte Vinci pour pouvoir y acc√©der.