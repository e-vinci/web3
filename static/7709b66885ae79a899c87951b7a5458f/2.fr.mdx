---
title: "Module 2 : React state"
description: "React state"
---
import 'bootstrap/dist/css/bootstrap.min.css';

# Module 2 : React state
Ce module vous offre principalement la d√©couverte de la gestion des √©v√©nements en React, ainsi que la gestion des √©tats.

# c) Destructuring et l'√©tat

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web3course </PathViewerItem>
    <PathViewerItem to="/modules/2" selected> Module 2 </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Destructuring </InternalPageMenuItem>
  <InternalPageMenuItem> Gestion de l'√©tat </InternalPageMenuItem>
  <InternalPageMenuItem> Gestionnaire d'√©v√©nements </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.1 : Destructing & composant stateful </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.2 : Composant de s√©lection de couleur </InternalPageMenuItem> 
  <InternalPageMenuItem> üç¨ Exercice 2.3 : Votre premier Hook custom ! </InternalPageMenuItem> 
  <InternalPageMenuItem> A retenir </InternalPageMenuItem> 
  <InternalPageMenuItem> Solution des exercices </InternalPageMenuItem> 
</InternalPageMenu>

# <InternalPageTitle> Destructuring  </InternalPageTitle>

Nous souhaitons am√©liorer la lisibilit√© de notre code et ne plus avoir √† taper `props.nomDeLaProps` au sein de nos composants React.

Pour ce tutoriel, veuillez cr√©er une copie de [start-state-starter](https://github.com/e-vinci/web3-exercises/tree/main/tutorials/start-state-starter), et l'appeler `start-state`. Changez le nom du projet dans `package.json`. Vous pouvez directement t√©l√©charger ce code via le site https://download-directory.github.io/ et le lien https://github.com/e-vinci/web3-exercises/tree/main/tutorials/start-state-starter

Veuillez d√©marrer l'application.

Nous allons mettre √† jour le code.  
Par exemple, nous pouvons simplifier ce composant `Header` :
```tsx
const Header = (props: HeaderProps) => {
  return (
    <header>
      <h1 className="animate__animated animate__bounce">{props.title}</h1>
      <h4>Version: {props.version}</h4>
    </header>
  );
};
```

Une premi√®re √©tape, en utilisant le "destructuring assignment", serait :
```tsx highlighting="2,5-6"
const Header = (props: HeaderProps) => {
  const { title, version } = props;
  return (
    <header>
      <h1 className="animate__animated animate__bounce">{title}</h1>
      <h4>Version: {version}</h4>
    </header>
  );
};
```

Mais nous pouvons faire le destructuring assignment directement dans le param√®tre de la fonction `Header` : 
```tsx highlighting="1,4-5"
const Header = ({ title, version }) => {
  return (
    <header>
      <h1 className="animate__animated animate__bounce">{title}</h1>
      <h4>Version: {version}</h4>
    </header>
  );
};
```

Ainsi, nous avons un code plus concis et plus clair : on sait directement quelles props le composant attend et utilise.  
üëç Dans la suite de ce cours, nous vous recommandons d'utiliser le destructuring assignment pour passer vos props. Cela rend le code plus lisible, on voit directement les param√®tres attendus par la fonction.

En plus de mettre √† jour `Header`, veuillez mettre √† jour `DrinkMenu` :
```tsx highlighting="1,4-5"
const DrinkMenu = ({ title, children }) => {
  return (
    <div className="drink-menu">
      <h4>{title}</h4>
      <div className="drink-items">{children}</div>
    </div>
  );
};
```

Veuillez aussi mettre √† jour `DrinkCard` :
```tsx highlighting="1,4-6"
const DrinkCard = ({ title, image, children }) => {
  return (
    <div className="drink-card">
      <img src={image} alt={title} className="drink-image" width="50" />
      <h2>{title}</h2>
      <div className="drink-details">{children}</div>
    </div>
  );
};
```

# <InternalPageTitle> Gestion de l'√©tat  </InternalPageTitle>

## Comment g√©rer l'affichage de nouvelles informations ?
Jusque l√†, toutes les UI que nous avons d√©velopp√©es ne changent pas d'apparence apr√®s le premier rendu.

N√©anmoins, il y a plein de cas o√π nous souhaiterions avoir une UI qui se "re-render", se "r√©-affiche", apr√®s un √©v√©nement, tel qu'une action des utilisateurs ou un √©v√©nement temporel. 

Par exemple, nous souhaiterions que dans notre application, lorsqu'on clique sur le `Header`, nous affichions un message au sein de ce `Header`.

Si nous faisions de la programmation "old school", que l'on appelle la **programmation "imp√©rative"**, nous devrions nous m√™me :
- attacher des fonctions √† notre UI qui permettent de g√©rer les √©v√©nements. Lors d'un clic par exemple, on devrait r√©cup√©rer une r√©f√©rence vers la repr√©sentation m√©moire du `<header>`;
- mettre √† jour le contenu HTML de cette repr√©sentation, g√©n√©ralement via la propri√©t√© `.innerHTML` de `<header>` en lui passant le message √† afficher (soit sous forme de string, soit en attachant un nouvel √©l√©ment m√©moire correspondant au message).
Le browser se charge ensuite de r√©afficher la page une fois la structure m√©moire de la page mise √† jour par le JS/TS.

Ici, comme nous utilisons React, nous faisons de la **programmation "d√©clarative"**. Nous d√©clarons des UI (via des composants React), et si nous souhaitons rafra√Æchir les pages, nous devons :
- d√©clarer un √©tat associ√© √† notre UI. L'√©tat de notre application, c'est toutes les variables qui vont pouvoir amener √† un changement de notre UI.
- attacher notre UI √† des variables d'√©tat.
- attacher des fonctions √† notre UI qui permettent de g√©rer les √©v√©nements. Lors d'un event, ces fonctions doivent informer React qu'il y a eu un changement d'√©tat.
- laisser la magie de l'outil (React ici) mettre √† jour toutes les parties de l'UI qui sont impact√©es par le changement d'√©tat : on parle de "re-rendering".
Ces m√©canismes permettent de bien simplifier et optimiser le rendering d'UI.

Voyons ce que √ßa donne dans la pratique !

## Composant stateful

Un composant "stateful" est un composant qui a un √©tat, c'est √† dire au moins une variable qui va permettre de rafra√Æchir l'UI.

Pour notre tutoriel, nous allons cr√©er la variable d'√©tat `messagePrinted` qui sera un bool√©en permettant de savoir si l'on affiche ou pas le message cach√© du `Header`. Nous allons aussi avoir une fonction `setMessagePrinted` pour changer la valeur du bool√©en.

Mettons √† jour le composant `Header` (qui se trouve dans `/src/components/Main/index.tsx`) :
```tsx numbered highlighting="1,10,13,15"
import { useState } from "react";
import "./Header.css";

const Header = ({ title, version }) => {
  const [menuPrinted, setMenuPrinted] = useState(false);

  return (
    <header onClick={() => setMenuPrinted(!menuPrinted)}>
      <h1 className="animate__animated animate__bounce">
        {menuPrinted ? `${title}... and rarely do we hate it!` : title}
      </h1>
      <h4>Version: {version}</h4>
    </header>
  );
};

export default Header;
```

D'abord, nous avons import√© le hook `useState` de React, qui permet aux composants fonctionnels de g√©rer leur √©tat interne.

`useState(false)` initialise une variable d'√©tat `menuPrinted` avec une valeur initiale de `false`.  
`setMenuPrinted` est une fonction qui permet de mettre √† jour l'√©tat `menuPrinted`. Elle est conventionnellement nomm√©e avec `set` suivi du nom de la variable d'√©tat (`MenuPrinted` dans ce cas).

Que fait ce morceau de code ? 
```tsx
<header onClick={() => setMenuPrinted(!menuPrinted)}>
```

Cela attache un gestionnaire d'√©v√©nements `onClick` √† l'√©l√©ment `<header>`.
`onClick` s'attend √† recevoir une fonction ! Ici on lui a pass√© une "function arrow" qui ne prend aucun param√®tre.  
Lorsque le **`<header>`** est cliqu√©, la fonction bascule l'√©tat `menuPrinted` en appelant `setMenuPrinted(!menuPrinted)` : si `menuPrinted` est √† `false`, sa valeur est chang√©e vers `true`, et vice versa.

La fonction `setMenuPrinted`, qui permet de changer l'√©tat, va informer React qu'il y a eu un changement d'√©tat ! Et donc React va op√©rer un re-render.

Lorsqu'un composant React subit un re-render, seule la fonction de rendu (c'est-√†-dire la fonction qui contient le `return` et qui d√©finit l'interface utilisateur du composant) est r√©√©valu√©e.

Finalement, lors du rerender, nous allons assurer un rendu conditionnel sur base de la variable d'√©tat :
```tsx
{menuPrinted ? `${title}... and rarely do we hate it!` : title}
```

Notons que nous avons utilis√© ici l'op√©rateur ternaire :  
`condition ? valeurSiVraie : valeurSiFausse`

Cette op√©rateur permet d'avoir du code plus concis. Si nous ne l'avions pas utilis√©, nous aurions du √©crire quelque chose du style :
```tsx
const Header = ({ title, version }) => {
  const [menuPrinted, setMenuPrinted] = useState(false);

  if (!menuPrinted) {
    return (
      <header onClick={() => setMenuPrinted(!menuPrinted)}>
        <h1 className="animate__animated animate__bounce">{title}</h1>
        <h4>Version: {version}</h4>
      </header>
    );
  }

  return (
    <header onClick={() => setMenuPrinted(!menuPrinted)}>
      <h1 className="animate__animated animate__bounce">
        {`${title}... and rarely do we hate it!`}
      </h1>
      <h4>Version: {version}</h4>
    </header>
  );
};
```
Ce code contient des r√©p√©titions et est moins lisible.

# <InternalPageTitle> Gestionnaire d'√©v√©nements </InternalPageTitle>

Un gestionnaire d'√©v√©nement est une fonction.

```tsx highlighting="5"
const Header = ({ title, version }) => {
  const [menuPrinted, setMenuPrinted] = useState(false);

  return (
    <header onClick={() => setMenuPrinted(!menuPrinted)}>
      <h1 className="animate__animated animate__bounce">
        {menuPrinted ? `${title}... and rarely do we hate it!` : title}
      </h1>
      <h4>Version: {version}</h4>
    </header>
  );
};
```

Nous pouvons d√©finir cette fonction comme "function arrow" (comme fait ci-dessus √† c√¥t√© de `onClick`),
mais aussi comme fonction anonyme ou fonction nomm√©e.

Lorsqu'une fonction commence √† avoir plusieurs instructions, il est recommand√© de cr√©er une fonction nomm√©e.  
En voici un exemple √† reprendre dans votre tutoriel dans le composant `Header` :

```tsx numbered highlighting="4-7,10"
const Header = ({ title, version }) => {
  const [menuPrinted, setMenuPrinted] = useState(false);

  const handleClick = () => {
    console.log(`value of menuPrinted before click: ${menuPrinted}`);
    setMenuPrinted(!menuPrinted);
  }

  return (
    <header onClick={handleClick}>
      <h1 className="animate__animated animate__bounce">
        {menuPrinted ? `${title}... and rarely do we hate it!` : title}
      </h1>
      <h4>Version: {version}</h4>
    </header>
  );
};
```

üëç Il est recommand√© que vos fonctions de gestion d'√©v√©nements re√ßoivent un unique param√®tre et portent un nom qui commence par **"handle"** afin de les identifier facilement.


‚ö°Ô∏è Attention, un attributs d'√©v√©nement (`onClick`...) doit **recevoir une fonction** en valeur !  
Une erreur classique est de lui passer l'**appel d'une fonction**, comme par exemple : 
```tsx
<header onClick={handleClick()}>
```

Ici √ßa veut dire que d√®s que le script est appel√©, √† l'initialisation de l'application, on va automatiquement faire l'appel √† `handleClick`, bien qu'il n'y ait pas eu de clic...

Allez-y, veuillez tester pour voir ce que cette erreur classique provoque...
`Error: Too many re-renders. React limits the number of renders to prevent an infinite loop.` üò±.

üí≠ Veuillez prendre un moment, au niveau de la compr√©hension de React, pour voir si vous savez expliquer pourquoi on va vers une boucle infinie.

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [start-state](https://github.com/e-vinci/web3-exercises/tree/main/tutorials/start-state).

# <InternalPageTitle> Exercice 2.1 : Destructing & composant stateful </InternalPageTitle>


Veuillez cr√©er un nouveau projet nomm√© `/exercises/2.1` dans votre git repo.

Par d√©faut, le projet de base vous offre d√©j√† un compteur de clic.

Commencez par prendre quelques minutes pour comprendre ce code et externaliser le compteur de clics dans un composant stateful nomm√© `ClickCounter`. 

Une fois tout fonctionnel et le code compris, veuillez faire un commit avec le message suivant : **`new:ex2.1-init`**.

Veuillez ensuite mettre √† jour ce composant pour afficher :
- un titre qu'il re√ßoit en props. 
- un message sous le nombre de clics √† afficher seulement √† partir de 10 clics. Ce message doit √™tre pass√© en props. Vous passerez cette valeur pour votre application : `"You are a master in the art of clicking !"`.


Veuillez utiliser le "destructing assignment" comme vu dans le cours.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.1-destructuring`**.

Veuillez continuer votre application et ajouter deux gestionnaires d'√©v√©nements qui permettront : 
- lors du passage de la souris sur le compteur, d'afficher un message au dessus du comptage de clics. Notez que ce message doit aussi √™tre pass√© en props √† `ClickCounter`.  
Vous passerez cette valeur pour votre application : `"Please click on me now !"`.
- lorsque la souris quitte le compteur, ce message doit √™tre enlev√©.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.1-events`**.

#### ü§ù Tips
- Vous allez devoir g√©rer une nouvelle variable d'√©tat pour savoir si la souris est sur le compteur ou si la souris a quitt√© le compteur.
- Quels gestionnaires d'√©v√©nements ? Commencer √† taper `on` en propri√©t√©s de l'√©l√©ment sur lequel vous voulez √©couter les passages de souris et vous verrez la liste de tous les √©v√©nements. 
- Vous ne voyez toujours pas ? `onMouseEnter`, `onMouseLeave` ; )
- N'h√©sitez pas √† utiliser tout ce qui existe d√©j√† dans `index.css` concernant le button pour vous aider √† g√©rer l'aspect visuel du compteur.

## Sauvegarder le compteur

Pour cet exercice, toujours dans `/exercises/2.1`, dans le composant `ClickCounter`, appelez `localStorage.setItem("count", JSON.stringify(count))` √† chaque fois qu'on change le compteur. Dans notre cas ici, c'est juste apr√®s l'appel √† la m√©thode `setCount` (dans le gestionnaire d'√©v√©nements associ√©s √† `onClick`, nomm√© par exemple `handleCount` si vous avez cr√©√© une fonction nomm√©e, ou dans une fonction arrow...).

Ensuite, dans le `useState(0)`, au lieu de donner **0** comme valeur initiale au compteur, essayez de lire la valeur du compteur depuis le localStorage `JSON.parse(localStorage.getItem("count"))` et passez la au `useState` comme valeur par d√©faut. Rafra√Æchissez votre page apr√®s le changement du compteur, et constatez qu'il persiste.

Vous remarquerez cependant qu'il y a un souci avec la valeur du compteur qui persiste. Il y a bien une persistance qui est faite, mais la valeur n'est pas correcte... Essayez de r√©fl√©chir √† la question, √©ventuellement en lisant la documentation officielle de React sur le hook `useState` : [Using the State Hook](https://reactjs.org/docs/hooks-state.html) [[R.6]](/references/#r6) ou sur le Render des composants : [Rendering Elements](https://reactjs.org/docs/rendering-elements.html) [[R.5]](/references/#r5).

Vous avez r√©fl√©chi √† la question ? V√©rifiez ci-dessous si vous avez trouv√© la "bonne" r√©ponse...

**======= SPOILER =======**

Au cas ou vous ne l'auriez pas compris, lorsque l'√©tat d√©fini gr√¢ce au `useState` vient √† changer, React re-render les composants qui sont impact√©s par ce changement. La seule mani√®re pour nous de changer la valeur du compteur, s'est d'utiliser le `setCount()` que le `useState` nous √† donn√©. L'appeler en donnant une nouvelle valeur va relancer un render. Mais React ne fait pas un render √† chaque changement d'un √©tat dans notre application. Il va optimiser les render pour √©viter d'en faire √† tout bout de champ. Le render sera fait quant il veut, sans que vous sachiez exactement quand... Du coup, √† la ligne juste apr√®s votre appel √† `setCount`, vous utilisez la valeur du counter en pensant qu'elle a √©t√© chang√©e, mais en fait, React ne la changera qu'au prochain render... Donc pas tout de suite ! Il faut donc trouver une petite parade ;-)

**======= FIN SPOILER =======**

Une fois que tout est en ordre, que le refresh n'alt√®re en rien la valeur du compteur affich√©e, 
veuillez faire un **commit** de votre code avec le message suivant : **`new:ex2.1-stored`**.

# <InternalPageTitle> Exercice 2.2 : Composant de s√©lection de couleur </InternalPageTitle>


Veuillez cr√©er un nouveau projet nomm√© `/exercises/2.2` dans votre git repo.

Veuillez cr√©er un composant React qui permette √† l'utilisateur de changer la couleur de fond d'une bo√Æte en cliquant sur un bouton.

Au sein de la bo√Æte (une **`div`** par exemple) ayant une taille fixe, veuillez afficher un bouton contenant le nom de la prochaine couleur disponible. Apr√®s chaque clic sur le bouton, la bo√Æte doit :
- prendre la couleur qui √©tait annonc√©e. 
- afficher un texte indiquant la couleur affich√©e (sous le bouton).

Veuillez pr√©voir un cycle de 5 couleurs : rouge, vert, bleu, jaune, violet. Apr√®s le violet, on revient au rouge. La premi√®re couleur √† afficher, sans action de l'utilisateur, est le rouge (et donc un bouton avec comme texte : "vert" et un texte "rouge" au-dessous du bouton). 

Veuillez utiliser votre composant React dans votre application principale pour afficher 3 bo√Æte dont la couleur peut changer.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.2`**.

#### ü§ù Tips
- Quel √©v√©nement g√©rer au niveau de la liste d√©roulante ?  
**`onChange`** ; )
- Plut√¥t que d'utiliser du CSS, vous pouvez utiliser des couleurs pr√©d√©finies dans React. Par exemple, pour le rouge, vous pouvez utiliser l'attribut **`style={{ backgroundColor: 'red' }}`**.

# <InternalPageTitle> üç¨ Exercice 2.3 : Votre premier Hook custom !  </InternalPageTitle>

*Ceci est un exercice facultatif, pour les plus motiv√©s !*

Veuillez cr√©er un nouveau projet nomm√© `/exercises/2.3` dans votre git repo, sur base d'un copier/coller de votre projet `/exercises/2.1`.

Vous aurez remarqu√© que le code de l'exercice 2.1 n'est pas tr√®s propre... A chaque appel de `setCounter()`, il ne faudra surtout pas oublier d'√©crire dans le localStorage... Et il faudra faire √ßa, pour chaque variable qu'on veut persister... Autant dire que c'est copier/coller du code partout, et le risque d'erreur est √©norme...

Et pourquoi ne pas faire notre propre **`useState`**, mais qui √©crit dans le localStorage au passage ?

√âcrivez un fichier **`src/hooks/useLocalStorage.js`** (notez l'extension **`.js`** et pas **`.jsx`**).  
Ce fichier doit d√©clarer et exporter une fonction **`useLocalStorage(key, initialValue)`**.  
Cette fonction utilisera en son coeur la fonction **`useState`** et comme elle, renverra une valeur et un setter. En plus de cela , elle stockera la valeur actuelle dans le localStorage √† l'indice de la clef donn√©e et chargera la valeur stock√©e initialement. Si la clef n'existe pas dans le localStorage, cette fonction initialisera la clef avec la valeur pass√©e en second param√®tre.

Attention ! N'oubliez pas de cr√©er "l'alias" pour le dossier hooks dans le fichier `vite.config.js` et le "path" dans le fichier `jsconfig.json`.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.3`**.

# <InternalPageTitle> A retenir </InternalPageTitle>

- **`useState`** permet de stocker un √©tat et de "rerender" les composants automatiquement quand c'est n√©cessaire.
- Les **props** sont la principale mani√®re de passer des donn√©es ET des fonctions.
- Les fonctions de gestion d'√©v√©nements re√ßoivent un unique param√®tre **`e`** qui repr√©sente l'√©v√©nement. Elles portent un nom qui commence par "handle" ou "on" afin de les identifier facilement.
- Les **hooks** sont des fonctions qui permettent d'ajouter des fonctionnalit√©s √† un composant fonctionnel.

# <InternalPageTitle> Solution des exercices </InternalPageTitle>

Une solution pour les exercices de ce module se trouvent ici : [module2](https://github.com/e-vinci/web3-exercises/tree/main/exercises/module2).

N'h√©sitez pas √† utiliser https://download-directory.github.io/ pour t√©l√©charger le dossier complet (sans devoir cloner tout le repo **`web3-exercises`**). Vous devez juste indiquer le lien vers le dossier **`module2`** dans le champ **`Download Directory`** : https://github.com/e-vinci/web3-exercises/tree/main/exercises/module2 puis taper sur la touche **`Enter`** de votre clavier.